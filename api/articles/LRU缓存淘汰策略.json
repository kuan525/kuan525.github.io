{"title":"LRU缓存淘汰策略","uid":"7d0e5e959c72a1d339ce2b2021e95c4f","slug":"LRU缓存淘汰策略","date":"2022-12-06T13:36:23.000Z","updated":"2022-12-06T13:36:49.027Z","comments":true,"path":"api/articles/LRU缓存淘汰策略.json","keywords":"kuan525","cover":null,"content":"<ul>\n<li>三种常用的淘汰（失效）算法：FIFO、LFU、LRU</li>\n<li>实现LRU缓存淘汰算法<h3 id=\"FOFO（First-In-First-Out）\"><a href=\"#FOFO（First-In-First-Out）\" class=\"headerlink\" title=\"FOFO（First In First Out）\"></a>FOFO（First In First Out）</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>先进先出，记录缓存中最老的记录，当空间不足的时候，放弃最老的这个即可，通常用一个队列实现。但是在很多地方，部分记录虽然是最早添加但也最经常访问，而不得不因为呆的时间太长而被淘汰。这类数据会被频繁的添加进缓存，又被淘汰出去，导致缓存命中率降低</p></blockquote>\n</li>\n</ul>\n<h3 id=\"LRU（Least-Frequently-Used）\"><a href=\"#LRU（Least-Frequently-Used）\" class=\"headerlink\" title=\"LRU（Least Frequently Used）\"></a>LRU（Least Frequently Used）</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>最少使用，也就是淘汰缓存中访问频率最低的记录，每次访问，访问次数加一，然后重新排序，类似于堆，时间上处理比较长。并且LFU算法受历史书籍的影响比较大。例如某个数据历史上访问次数奇高，但在某个时间点之后几乎不再被访问，但是因为历史访问次数过高，而迟迟不能被淘汰</p></blockquote>\n<h3 id=\"LRU（Least-Recently-Used）\"><a href=\"#LRU（Least-Recently-Used）\" class=\"headerlink\" title=\"LRU（Least Recently Used）\"></a>LRU（Least Recently Used）</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>最近最少使用，相对于仅考虑时间因素的FIFO和仅考虑访问频率的LFU，LRU算法可以认为是相对平衡的一种淘汰算法，LRU认为，如果数据最近被访问过，那么将来被访问的概率也会更高，LRU算法的实现非常简单，维护一个队列，如果某条记录被访问了，则移动到尾，那么队首则是最近最少访问的数据，淘汰该条记录即可</p></blockquote>\n<h3 id=\"LRU算法实现\"><a href=\"#LRU算法实现\" class=\"headerlink\" title=\"LRU算法实现\"></a>LRU算法实现</h3><h4 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h4><ol>\n<li>双向链表</li>\n<li>指向链表了的map，根据key索引位置<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">  \ntype Cache struct &#123;  \n   &#x2F;&#x2F; 最大空间  \n   maxBytes int64  \n   &#x2F;&#x2F; 当前使用空间  \n   nbytes int64  \n   &#x2F;&#x2F; 双向链表，里面的元素没有明确的类型，需要后面操作  \n   ll *list.List  \n   &#x2F;&#x2F; 通过key检索在链表当中的位置，指向链表的指针  \n   cache map[string]*list.Element  \n   &#x2F;&#x2F; 某条记录被移除时的回掉函数  \n   OnEvicted func(key string, value Value)  \n&#125;  \n  \n&#x2F;&#x2F; 链表当中的节点类型，k-v对  \ntype entry struct &#123;  \n   key   string  \n   value Value  \n&#125;  \n  \n&#x2F;&#x2F; 为了通用性，允许值是实现了Value接口对任意类型，只包含一个方法，用户返回所占内存大小  \ntype Value interface &#123;  \n   Len() int  \n&#125;</code></pre></li>\n<li>Go标准库实现的双向链表<code>list.list</code></li>\n<li>字典是<code>map[string]*list.Element*</code></li>\n<li>剩下的在注释中有写<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>为了方便实例化Cache，实现了New函数</p></blockquote>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 初始化实例Cache, 最大空间，回掉函数  \nfunc New(maxBytes int64, onEvicted func(string, Value)) *Cache &#123;  \n   return &amp;Cache&#123;  \n      maxBytes:  maxBytes,  \n      ll:        list.New(),  \n      cache:     make(map[string]*list.Element),  \n      OnEvicted: onEvicted,  \n   &#125;  \n&#125;</code></pre></li>\n</ol>\n<h4 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 查找  \nfunc (c *Cache) Get(key string) (value Value, ok bool) &#123;  \n   &#x2F;&#x2F; 不存在则直接退出，返回ok，因为下面没有实际返回值，所以返回上一行定义的  \n   if ele, ok :&#x3D; c.cache[key]; ok &#123;  \n      &#x2F;&#x2F; 获取到了ele（指针），将其移动到队尾（相对的）  \n      c.ll.MoveToFront(ele)  \n      &#x2F;&#x2F; 将其反序列化为entry类型，现在kv是entry类型，比如x.(int)  \n      &#x2F;&#x2F; 这里是指向entry到指针  \n      kv :&#x3D; ele.Value.(*entry)  \n      return kv.value, true  \n   &#125;  \n   return  \n&#125;</code></pre>\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 空间不足，现在移除近期访问最少的节点（队首）  \nfunc (c *Cache) RemoveOldest() &#123;  \n   &#x2F;&#x2F; 看队首有无节点  \n   ele :&#x3D; c.ll.Back()  \n   if ele !&#x3D; nil &#123;  \n      &#x2F;&#x2F; 删除  \n      c.ll.Remove(ele)  \n      &#x2F;&#x2F; 反序列会为一个entry  \n      kv :&#x3D; ele.Value.(*entry)  \n      &#x2F;&#x2F; 在cache中删除  \n      delete(c.cache, kv.key)  \n      &#x2F;&#x2F; 重新计算当前空间 -&#x3D; 之前的key的长度 + value的长度  \n      c.nbytes -&#x3D; int64(len(kv.key)) + int64(kv.value.Len())  \n      &#x2F;&#x2F; 若c.OnEvicted不为空，则调用回掉函数  \n      if c.OnEvicted !&#x3D; nil &#123;  \n         c.OnEvicted(kv.key, kv.value)  \n      &#125;  \n   &#125;  \n&#125;</code></pre>\n<h4 id=\"增加-修改\"><a href=\"#增加-修改\" class=\"headerlink\" title=\"增加/修改\"></a>增加/修改</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>和map一样，在原基础上可以改</p></blockquote>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 新增&#x2F;修改  \nfunc (c *Cache) Add(key string, value Value) &#123;  \n   &#x2F;&#x2F; 存在  \n   if ele, ok :&#x3D; c.cache[key]; ok &#123;  \n      &#x2F;&#x2F; 移到队尾  \n      c.ll.MoveToFront(ele)  \n      &#x2F;&#x2F; 获取entry  \n      kv :&#x3D; ele.Value.(*entry)  \n      &#x2F;&#x2F; 计算空间，减去原来的，加上当前的，key的长度没变  \n      c.nbytes +&#x3D; int64(value.Len()) - int64(kv.value.Len())  \n      &#x2F;&#x2F; 更新  \n      kv.value &#x3D; value  \n   &#125; else &#123;  \n      &#x2F;&#x2F; 不存在，则push一个  \n      ele :&#x3D; c.ll.PushFront(&amp;entry&#123;key, value&#125;)  \n      &#x2F;&#x2F; 新增，直接多一个  \n      c.cache[key] &#x3D; ele  \n      &#x2F;&#x2F; 计算空间，加上当前的key长度和value长度  \n      c.nbytes +&#x3D; int64(len(key)) + int64(value.Len())  \n   &#125;  \n  \n   &#x2F;&#x2F; 要是当前使用的空间超过了指定的最大空间，则反复删除，当最大为0时，则是人为操作，不管即可  \n   for c.maxBytes !&#x3D; 0 &amp;&amp; c.maxBytes &lt; c.nbytes &#123;  \n      c.RemoveOldest()  \n   &#125;  \n&#125;</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>我们实现以下Len函数，获取添加了多少条数据</p></blockquote>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func (c *Cache) Len() int &#123;  \n   return c.ll.Len()  \n&#125;</code></pre>","feature":true,"text":" 三种常用的淘汰（失效）算法：FIFO、LFU、LRU 实现LRU缓存淘汰算法FOFO（First In First Out） 先进先出，记录缓存中最老的记录，当空间不足的时候，放弃最老的这个即可，通常用一个队列实现。但是在很多地方，部分记录虽然是最早添加但也最经常访问，而不得不...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"GeeCache","slug":"GeeCache","count":3,"path":"api/tags/GeeCache.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#FOFO%EF%BC%88First-In-First-Out%EF%BC%89\"><span class=\"toc-text\">FOFO（First In First Out）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LRU%EF%BC%88Least-Frequently-Used%EF%BC%89\"><span class=\"toc-text\">LRU（Least Frequently Used）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LRU%EF%BC%88Least-Recently-Used%EF%BC%89\"><span class=\"toc-text\">LRU（Least Recently Used）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LRU%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">LRU算法实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">查找</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">删除</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A2%9E%E5%8A%A0-%E4%BF%AE%E6%94%B9\"><span class=\"toc-text\">增加&#x2F;修改</span></a></li></ol></li></ol>","author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}},"mapped":true,"prev_post":{"title":"单机并发缓存","uid":"cdfcbf875732425e5f8b3e1e1d3fdd75","slug":"单机并发缓存","date":"2022-12-09T14:40:58.000Z","updated":"2022-12-09T14:41:55.865Z","comments":true,"path":"api/articles/单机并发缓存.json","keywords":"kuan525","cover":null,"text":" 介绍sync.Mutex互斥锁的使用，并实现LRU缓存的并发控制 实现GeeCache核心数据结构Group，缓存不存在时，调用回调函数 sync.Mutex sync.Mutex是一个互斥锁，可以由不同的协程加锁和解锁 支持并发读写 其实就是在操作共享空间的时候，加一把锁 g...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"GeeCache","slug":"GeeCache","count":3,"path":"api/tags/GeeCache.json"}],"author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}},"feature":true},"next_post":{"title":"错误恢复","uid":"c641698123cd1e90bb25dbd165f925c7","slug":"错误恢复","date":"2022-12-06T07:42:59.000Z","updated":"2022-12-06T07:44:51.604Z","comments":true,"path":"api/articles/错误恢复.json","keywords":"kuan525","cover":null,"text":" 实现错误处理机制panic go语言中，比较常见的错误处理方法是返回error，由调用者决定后续如何处理。但是如果是无法恢复的错误，也可以手动触发panic，当然如果在程序运行过程中出现了类似的数组越界的错误，panic也会被触发。panic会终止当前执行的程序，退出。 def...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Gee","slug":"Gee","count":7,"path":"api/tags/Gee.json"}],"author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}}}}