{"title":"HTTP服务端","uid":"6cfdbde6709cc79c68a7fde666e7baae","slug":"HTTP服务端","date":"2022-12-09T16:42:52.000Z","updated":"2022-12-09T16:43:38.613Z","comments":true,"path":"api/articles/HTTP服务端.json","keywords":"kuan525","cover":null,"content":"<ul>\n<li>使用GO语言标准库http搭建HTTP Server<h3 id=\"http标准库\"><a href=\"#http标准库\" class=\"headerlink\" title=\"http标准库\"></a>http标准库</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>go语言提供了http标准库，可以非常方便的搭建HTTP服务端和客户端，以下我们无论收到什么请求，都返回字符串“Hello, World”</p></blockquote>\n</li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main  \n  \nimport (  \n\t&quot;log&quot;  \n\t&quot;net&#x2F;http&quot;  \n)  \n  \ntype server int  \n  \nfunc (h *server) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;  \n\tlog.Println(r.URL.Path)  \n\tw.Write([]byte(&quot;Hello World!&quot;))  \n&#125;  \n  \nfunc main() &#123;  \n\tvar s server  \n\thttp.ListenAndServe(&quot;localhost:9999&quot;, &amp;s)  \n&#125;</code></pre>\n<ol>\n<li>创建任意类型server，实现ServeHTTP方法</li>\n<li>调用<code>http.ListenAndServe</code>在9999端口启动http服务，处理对象为s，s为server，实现了ServeHTTP，可以当成handle用<h3 id=\"GeeCache-HTTP服务端\"><a href=\"#GeeCache-HTTP服务端\" class=\"headerlink\" title=\"GeeCache HTTP服务端\"></a>GeeCache HTTP服务端</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>分布式缓存需要实现节点间通信，建立基于HTTP的通信机制是比较常见和简单的做法。如果一个节点启动了HTTP服务，那么这个节点就可以被其他节点访问。</p></blockquote>\n</li>\n</ol>\n<p>当前代码结构：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">geecache&#x2F;  \n    |--lru&#x2F;  \n        |--lru.go  &#x2F;&#x2F; lru 缓存淘汰策略  \n    |--byteview.go &#x2F;&#x2F; 缓存值的抽象与封装  \n    |--cache.go    &#x2F;&#x2F; 并发控制  \n    |--geecache.go &#x2F;&#x2F; 负责与外部交互，控制缓存存储和获取的主流程  \n\t|--http.go     &#x2F;&#x2F; 提供被其他节点访问的能力(基于http)</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>创建一个HTTPPool，作为承载节点间HTTP通信的核心数据结构</p></blockquote>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">  \n&#x2F;&#x2F; basePath节点通讯地址的前缀，自定义，这样可以区分  \nconst defaultBasePath &#x3D; &quot;&#x2F;_geecache&#x2F;&quot;  \n  \ntype HTTPPool struct &#123;  \n   self     string &#x2F;&#x2F; 自己地址  \n   basePath string &#x2F;&#x2F; 通讯地址前缀  \n&#125;  \n  \nfunc NewHTTPPool(self string) *HTTPPool &#123;  \n   return &amp;HTTPPool&#123;  \n      self:     self,  \n      basePath: defaultBasePath,  \n   &#125;  \n&#125;</code></pre>\n<ol>\n<li>HTTPPool有两个参数，一个是self，用来记录自己的地址，包括主机名/IP和端口</li>\n<li>另一个是BasePath，作为节点间通讯地址的前缀，默认是<code>/_geecache/</code>，那么<code>http://example.com/_geecache/</code>开头的请求，就用语节点间的访问，因为一个主机还可以承载其他的服务，加一段path是一个好习惯，比如，大部分网站上API接口，一般以/api作为前缀<br>ServeHTTP实现方法：<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">  \nfunc (p *HTTPPool) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;  \n   &#x2F;&#x2F; 匹配前缀  \n   if !strings.HasPrefix(r.URL.Path, p.basePath) &#123;  \n      panic(&quot;HTTPPool serving unexpected path: &quot; + r.URL.Path)  \n   &#125;  \n  \n   p.Log(&quot;%s %s&quot;, r.Method, r.URL.Path)  \n  \n   &#x2F;&#x2F; 拆分  \n   parts :&#x3D; strings.SplitN(r.URL.Path[len(p.basePath):], &quot;&#x2F;&quot;, 2)  \n   if len(parts) !&#x3D; 2 &#123;  \n      http.Error(w, &quot;bad request&quot;, http.StatusBadRequest)  \n      return  \n   &#125;  \n  \n   groupName :&#x3D; parts[0] &#x2F;&#x2F; 通信前缀  \n   key :&#x3D; parts[1]       &#x2F;&#x2F; key  \n  \n   &#x2F;&#x2F; 得到当前通信前缀所在的命名空间group  \n   group :&#x3D; GetGroup(groupName)  \n   if group &#x3D;&#x3D; nil &#123;  \n      http.Error(w, &quot;no such group: &quot;+groupName, http.StatusNotFound)  \n      return  \n   &#125;  \n  \n   &#x2F;&#x2F; 取到缓存  \n   view, err :&#x3D; group.Get(key)  \n   if err !&#x3D; nil &#123;  \n      http.Error(w, err.Error(), http.StatusInternalServerError)  \n      return  \n   &#125;  \n  \n   &#x2F;&#x2F; 稍微设置一下  \n   w.Header().Set(&quot;Content-Type&quot;, &quot;application&#x2F;octet-stream&quot;)  \n   w.Write(view.ByteSlice())  \n&#125;</code></pre></li>\n<li>serveHTTP首先判断访问路径前缀是否是basePath，不是则返回错误</li>\n<li>我们约定访问格式为<code>/&lt;basepath&gt;/&lt;groupname&gt;/&lt;key&gt;</code>，通过groupname得到group实例，在使用`group.Get(key)· 获取缓存数据</li>\n<li>最终使用<code>w.Write()</code>将缓存值作为<code>httpResponse</code>的body返回<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3>用一下main测试：<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main  \n  \nimport (  \n   &quot;fmt&quot;  \n   &quot;geecache&quot;   &quot;log&quot;   &quot;net&#x2F;http&quot;)  \n  \nvar db &#x3D; map[string]string&#123;  \n   &quot;Tom&quot;:  &quot;630&quot;,  \n   &quot;Jack&quot;: &quot;589&quot;,  \n   &quot;Sam&quot;:  &quot;567&quot;,  \n&#125;  \n  \nfunc main() &#123;  \n   geecache.NewGroup(&quot;scores&quot;, 2&lt;&lt;10, geecache.GetterFunc(  \n      func(key string) ([]byte, error) &#123;  \n         log.Println(&quot;[SlowDB] search key&quot;, key)  \n         if v, ok :&#x3D; db[key]; ok &#123;  \n            return []byte(v), nil  \n         &#125;  \n         return nil, fmt.Errorf(&quot;%s not exist&quot;, key)  \n      &#125;))  \n  \n   addr :&#x3D; &quot;localhost:9999&quot;  \n   peers :&#x3D; geecache.NewHTTPPool(addr)  \n   log.Println(&quot;geecache is running at&quot;, addr)  \n   log.Fatal(http.ListenAndServe(addr, peers))  \n&#125;</code></pre>\n运行结果：<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;_geecache&#x2F;scores&#x2F;Tom  \n630  \n$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;_geecache&#x2F;scores&#x2F;kkk  \nkkk not exist</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>需要注意的点：<br>main.go 和 geecache/ 在同级目录，但 go modules 不再支持 import &lt;相对路径&gt;，相对路径需要在 go.mod 中声明：<br>require geecache v0.0.0<br>// require geecache v0.0.0-00010101000000-000000000000<br>replace geecache =&gt; ./geecache</p></blockquote>\n</li>\n</ol>\n","feature":true,"text":" 使用GO语言标准库http搭建HTTP Serverhttp标准库 go语言提供了http标准库，可以非常方便的搭建HTTP服务端和客户端，以下我们无论收到什么请求，都返回字符串“Hello, World” package main import ( &quot;log&quo...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"GeeCache","slug":"GeeCache","count":4,"path":"api/tags/GeeCache.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#http%E6%A0%87%E5%87%86%E5%BA%93\"><span class=\"toc-text\">http标准库</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GeeCache-HTTP%E6%9C%8D%E5%8A%A1%E7%AB%AF\"><span class=\"toc-text\">GeeCache HTTP服务端</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">测试</span></a></li></ol>","author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}},"mapped":true,"prev_post":{"title":"一致性哈希","uid":"9bcc4dbf5fd0afda677727e925c7a91f","slug":"一致性哈希","date":"2022-12-10T03:42:33.000Z","updated":"2022-12-10T03:43:04.430Z","comments":true,"path":"api/articles/一致性哈希.json","keywords":"kuan525","cover":null,"text":" 一致性哈希的原理以及为什么要使用一致性哈希 实现一致性哈希为什么使用一致性哈希 对于分布式缓存来说，当一个节点接收到请求，如果该节点并没有存储缓存值，那么它面临的难题时，从谁那里获取源数据。假设第一次随机选择了节点1，节点1从数据源获取到数据的同时缓存该数据，那第二次只有1/1...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"GeeCache","slug":"GeeCache","count":4,"path":"api/tags/GeeCache.json"}],"author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}},"feature":true},"next_post":{"title":"单机并发缓存","uid":"cdfcbf875732425e5f8b3e1e1d3fdd75","slug":"单机并发缓存","date":"2022-12-09T14:40:58.000Z","updated":"2022-12-09T14:41:55.865Z","comments":true,"path":"api/articles/单机并发缓存.json","keywords":"kuan525","cover":null,"text":" 介绍sync.Mutex互斥锁的使用，并实现LRU缓存的并发控制 实现GeeCache核心数据结构Group，缓存不存在时，调用回调函数 sync.Mutex sync.Mutex是一个互斥锁，可以由不同的协程加锁和解锁 支持并发读写 其实就是在操作共享空间的时候，加一把锁 g...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"GeeCache","slug":"GeeCache","count":4,"path":"api/tags/GeeCache.json"}],"author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}},"feature":true}}