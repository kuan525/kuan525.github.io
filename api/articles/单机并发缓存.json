{"title":"单机并发缓存","uid":"cdfcbf875732425e5f8b3e1e1d3fdd75","slug":"单机并发缓存","date":"2022-12-09T14:40:58.000Z","updated":"2022-12-09T14:41:55.865Z","comments":true,"path":"api/articles/单机并发缓存.json","keywords":"kuan525","cover":null,"content":"<ul>\n<li>介绍sync.Mutex互斥锁的使用，并实现LRU缓存的并发控制</li>\n<li>实现GeeCache核心数据结构Group，缓存不存在时，调用回调函数</li>\n</ul>\n<h3 id=\"sync-Mutex\"><a href=\"#sync-Mutex\" class=\"headerlink\" title=\"sync.Mutex\"></a>sync.Mutex</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>sync.Mutex是一个互斥锁，可以由不同的协程加锁和解锁</p></blockquote>\n<h3 id=\"支持并发读写\"><a href=\"#支持并发读写\" class=\"headerlink\" title=\"支持并发读写\"></a>支持并发读写</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>其实就是在操作共享空间的时候，加一把锁</p></blockquote>\n<p><code>geecache/byteview.go</code></p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 缓存值的抽象与封装  \npackage GeeCache  \n  \n&#x2F;&#x2F; ByteView只有一个数据成员，回存储真实的缓存值，选择byte是为了能支持任意的  \n&#x2F;&#x2F; 数据类型的存储，例如字符串、图片  \ntype ByteView struct &#123;  \n   b []byte  \n&#125;  \n  \n&#x2F;&#x2F; 返回内存大小  \nfunc (v ByteView) Len() int &#123;  \n   return len(v.b)  \n&#125;  \n  \n&#x2F;&#x2F; 返回一个拷贝  \nfunc (v ByteView) ByteSlice() []byte &#123;  \n   return cloneBytes(v.b)  \n&#125;  \n  \n&#x2F;&#x2F; 转为string  \nfunc (v ByteView) String() string &#123;  \n   return string(v.b)  \n&#125;  \n  \n&#x2F;&#x2F; 复制一份  \nfunc cloneBytes(b []byte) []byte &#123;  \n   c :&#x3D; make([]byte, len(b))  \n   copy(c, b)  \n   return c  \n&#125;</code></pre>\n<ol>\n<li>Byte只有一个数据成员，会存储真实的缓存值，选择byte类型时为了支持任意的数据类型的存储，例如字符串、图片</li>\n<li>实现<code>Len() int</code>方法，我们在lru.Cache的实现中，要求被缓存对象必须实现Value接口，即<code>Len() int</code>方法，返回其所占的内存大小</li>\n<li><code>b</code>时只读的，使用<code>ByteSlice()</code>方法返回一个拷贝，防止缓存值被外部程序修改</li>\n</ol>\n<p><code>geecache/cache.go</code></p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 并发控制  \npackage GeeCache  \n  \nimport (  \n   &quot;geeCache&#x2F;lru&quot;  \n   &quot;sync&quot;)  \n  \ntype cache struct &#123;  \n   mu         sync.Mutex  \n   lru        *lru.Cache  \n   cacheBytes int64  \n&#125;  \n  \nfunc (c *cache) add(key string, value ByteView) &#123;  \n   c.mu.Lock()  \n   defer c.mu.Unlock()  \n   &#x2F;&#x2F; 延迟初始化，提高性能  \n   if c.lru &#x3D;&#x3D; nil &#123;  \n      c.lru &#x3D; lru.New(c.cacheBytes, nil)  \n   &#125;  \n   c.lru.Add(key, value)  \n&#125;  \n  \nfunc (c *cache) get(key string) (value ByteView, ok bool) &#123;  \n   c.mu.Lock()  \n   defer c.mu.Unlock()  \n   if c.lru &#x3D;&#x3D; nil &#123;  \n      return  \n   &#125;  \n  \n   if v, ok :&#x3D; c.lru.Get(key); ok &#123;  \n      return v.(ByteView), ok  \n   &#125;  \n  \n   return  \n&#125;</code></pre>\n<ul>\n<li>实例化lru，封装get和add方法，并添加互斥锁mu</li>\n<li>在add中，判断是否为空，如果是空再创建实例，这种方法称之为延迟初始化，一个对象的延迟初始化意味着该对象的创建将会延迟至第一次使用该对象时，主要用于提升性能，并减少程序内存要求<h3 id=\"主体结构Group\"><a href=\"#主体结构Group\" class=\"headerlink\" title=\"主体结构Group\"></a>主体结构Group</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Group是GeeCache最核心的数据结构，负责与用户的交互，并且控制缓存值存储和获取的流程</p></blockquote>\n</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">                            是  \n接收 key --&gt; 检查是否被缓存 -----&gt; 返回缓存值 ⑴  \n                |  否                         是  \n                |-----&gt; 是否应当从远程节点获取 -----&gt; 与远程节点交互 --&gt; 返回缓存值 ⑵  \n                            |  否  \n                            |-----&gt; 调用&#96;回调函数&#96;，获取值并添加到缓存 --&gt; 返回缓存值 ⑶</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>我们将在<code>geecache.go</code>中实现主体结构Group，那么GeeCache的代码结构的雏形已经形成了。</p></blockquote>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">geecache&#x2F;  \n    |--lru&#x2F;  \n        |--lru.go  &#x2F;&#x2F; lru 缓存淘汰策略  \n    |--byteview.go &#x2F;&#x2F; 缓存值的抽象与封装  \n    |--cache.go    &#x2F;&#x2F; 并发控制  \n    |--geecache.go &#x2F;&#x2F; 负责与外部交互，控制缓存存储和获取的主流程</code></pre>\n\n<h4 id=\"回调Getter\"><a href=\"#回调Getter\" class=\"headerlink\" title=\"回调Getter\"></a>回调Getter</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里需要去复习一下接口的知识，下面还会用到函数型接口<br>设计Getter目的：当缓存不存在的时候，调用这个函数，得到源数据</p></blockquote>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; A Getter loads data for a key.  \ntype Getter interface &#123;  \n\tGet(key string) ([]byte, error)  \n&#125;  \n  \n&#x2F;&#x2F; A GetterFunc implements Getter with a function.  \ntype GetterFunc func(key string) ([]byte, error)  \n  \n&#x2F;&#x2F; Get implements Getter interface function  \nfunc (f GetterFunc) Get(key string) ([]byte, error) &#123;  \n\treturn f(key)  \n&#125;</code></pre>\n<ol>\n<li>定义接口Getter和回调函数Get（key string)([]byte, error)</li>\n<li>定义函数类型GetterFunc，并实现Getter接口的Get方法</li>\n<li>函数类型实现某一个接口，称之为接口型函数，方便使用者在调用时技能传入函数作为参数，也能够传入实现了该接口的结构体作为参数</li>\n</ol>\n<p><strong>价值：我们可以有多种方式调用该函数</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>定义一个函数型F，并在实现接口A的方法，然后在这个方法中调用自己，这是Go语言中将其他函数（参数返回值定义与F一致）转换为接口A的常用技巧</p></blockquote>\n<h4 id=\"Group的定义\"><a href=\"#Group的定义\" class=\"headerlink\" title=\"Group的定义\"></a>Group的定义</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">  \n&#x2F;&#x2F; 一个Group可以被认为是一个缓存的命名空间  \ntype Group struct &#123;  \n   name      string &#x2F;&#x2F; 名称  \n   getter    Getter &#x2F;&#x2F; 回调函数（callback）  \n   mainCache cache  &#x2F;&#x2F; 一开始实现的并发缓存  \n&#125;  \n  \nvar (  \n   mu     sync.RWMutex              &#x2F;&#x2F; 只读锁  \n   groups &#x3D; make(map[string]*Group) &#x2F;&#x2F; 将group存储在这里  \n)  \n  \n&#x2F;&#x2F; 初始化  \nfunc NewGroup(name string, cacheBytes int64, getter Getter) *Group &#123;  \n   if getter &#x3D;&#x3D; nil &#123;  \n      panic(&quot;nil Getter&quot;)  \n   &#125;  \n  \n   mu.Lock()  \n   defer mu.Unlock()  \n  \n   g :&#x3D; &amp;Group&#123;  \n      name:      name,  \n      getter:    getter,  \n      mainCache: cache&#123;cacheBytes: cacheBytes&#125;,  \n   &#125;  \n  \n   groups[name] &#x3D; g  \n   return g  \n&#125;  \n  \nfunc GetGroup(name string) *Group &#123;  \n   mu.RLock()  \n   g :&#x3D; groups[name]  \n   mu.RUnlock()  \n   return g  \n&#125;</code></pre>\n<ol>\n<li>一个Group可以被认为是一个缓存的命名空间，每一个Group拥有一个唯一的名称name</li>\n<li>第二个属性时<code>getter Getter</code>，即缓存未命中时获取源数据的回调（callback）</li>\n<li>第三个是<code>mainCache cache</code>，即一开始实现的并发缓存</li>\n</ol>\n<h4 id=\"Group中的Get方法\"><a href=\"#Group中的Get方法\" class=\"headerlink\" title=\"Group中的Get方法\"></a>Group中的Get方法</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>最核心的方法Get</p></blockquote>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">  \n&#x2F;&#x2F; 先查找，找不到缓存，则调用load，load调用getLocally，再调用get获取，并加进去  \nfunc (g *Group) Get(key string) (ByteView, error) &#123;  \n   if key &#x3D;&#x3D; &quot;&quot; &#123;  \n      return ByteView&#123;&#125;, fmt.Errorf(&quot;key is required&quot;)  \n   &#125;  \n  \n   if v, ok :&#x3D; g.mainCache.get(key); ok &#123;  \n      log.Println(&quot;[GeeCache] hit&quot;)  \n      return v, nil  \n   &#125;  \n  \n   return g.load(key)  \n&#125;  \n  \n&#x2F;&#x2F; 加载一条  \nfunc (g *Group) load(key string) (value ByteView, err error) &#123;  \n   return g.getLocally(key)  \n&#125;  \n  \n&#x2F;&#x2F; 底层封装  \nfunc (g *Group) getLocally(key string) (ByteView, error) &#123;  \n   bytes, err :&#x3D; g.getter.Get(key)  \n   if err !&#x3D; nil &#123;  \n      return ByteView&#123;&#125;, err  \n   &#125;  \n  \n   value :&#x3D; ByteView&#123;b: cloneBytes(bytes)&#125;  \n   g.populateCache(key, value)  \n   return value, nil  \n&#125;  \n  \n&#x2F;&#x2F; 加入  \nfunc (g *Group) populateCache(key string, value ByteView) &#123;  \n   g.mainCache.add(key, value)  \n&#125;</code></pre>\n<p>当缓存不存在时，则调用load方法，load调用getLocally（分布式场景下会调用getFromPeer从其他节点获取），getLocally调用用户回调函数<code>g.getter.Get()</code>获取源数据，并且将原书记添加到缓存mainCache中（通过populateCache方法）</p>\n","feature":true,"text":" 介绍sync.Mutex互斥锁的使用，并实现LRU缓存的并发控制 实现GeeCache核心数据结构Group，缓存不存在时，调用回调函数 sync.Mutex sync.Mutex是一个互斥锁，可以由不同的协程加锁和解锁 支持并发读写 其实就是在操作共享空间的时候，加一把锁 g...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"GeeCache","slug":"GeeCache","count":3,"path":"api/tags/GeeCache.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#sync-Mutex\"><span class=\"toc-text\">sync.Mutex</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%94%AF%E6%8C%81%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99\"><span class=\"toc-text\">支持并发读写</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E4%BD%93%E7%BB%93%E6%9E%84Group\"><span class=\"toc-text\">主体结构Group</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E8%B0%83Getter\"><span class=\"toc-text\">回调Getter</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Group%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">Group的定义</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Group%E4%B8%AD%E7%9A%84Get%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Group中的Get方法</span></a></li></ol></li></ol>","author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}},"mapped":true,"prev_post":{"title":"HTTP服务端","uid":"6cfdbde6709cc79c68a7fde666e7baae","slug":"HTTP服务端","date":"2022-12-09T16:42:52.000Z","updated":"2022-12-09T16:43:31.542Z","comments":true,"path":"api/articles/HTTP服务端.json","keywords":"kuan525","cover":null,"text":" 使用GO语言标准库http搭建HTTP Serverhttp标准库 go语言提供了http标准库，可以非常方便的搭建HTTP服务端和客户端，以下我们无论收到什么请求，都返回字符串“Hello, World” package main import ( &quot;log&quo...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"GeeCache","slug":"GeeCache","count":3,"path":"api/tags/GeeCache.json"}],"author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}},"feature":true},"next_post":{"title":"LRU缓存淘汰策略","uid":"7d0e5e959c72a1d339ce2b2021e95c4f","slug":"LRU缓存淘汰策略","date":"2022-12-06T13:36:23.000Z","updated":"2022-12-06T13:36:49.027Z","comments":true,"path":"api/articles/LRU缓存淘汰策略.json","keywords":"kuan525","cover":null,"text":" 三种常用的淘汰（失效）算法：FIFO、LFU、LRU 实现LRU缓存淘汰算法FOFO（First In First Out） 先进先出，记录缓存中最老的记录，当空间不足的时候，放弃最老的这个即可，通常用一个队列实现。但是在很多地方，部分记录虽然是最早添加但也最经常访问，而不得不...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"GeeCache","slug":"GeeCache","count":3,"path":"api/tags/GeeCache.json"}],"author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}},"feature":true}}