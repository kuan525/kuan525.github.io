{"title":"上下文Context","uid":"cc752e8912b50d572e9477f30896c7fb","slug":"上下文Context","date":"2022-12-02T08:54:00.000Z","updated":"2022-12-03T08:09:01.868Z","comments":true,"path":"api/articles/上下文Context.json","keywords":"kuan525","cover":null,"content":"<ul>\n<li>将<code>路由（router）</code>独立出来，方便之后增强</li>\n<li>设计<code>上下文（Context）</code>，封装Request和Response，提供对JSON、HTML等返回类型的支持</li>\n</ul>\n<h3 id=\"设计Context\"><a href=\"#设计Context\" class=\"headerlink\" title=\"设计Context\"></a>设计Context</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>对于web服务器来说，无非是根据请求<em>http。Request，构造响应http.ResponseWriter。但是这两个对象提供的接口颗粒太细，比如我们要构造一个完整的响应，需要考虑消息头（Header）和消息体</em>（Body），而Header包含了状态码（StatusCode），消息类型（ContentType）等几乎每次请求都需要设置的信息。因此，如果不进行有效的封装，那么框架的用户将需要写出大量重复，繁杂的代码，而且容易出错，针对常用场景，能够高效地构造HTTP响应是一个好的框架必须考虑的点</li>\n<li>针对使用场景，封装*http.Request和http.ResponseWriter的方法，简化相关接口的调用，只是设计Context的原因之一。对于框架来说，还需要支撑额外的功能，例如，将来解析动态路由，或者框架需要中间件。Context随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由Context承载，因此，设计Context结构，扩展性和复杂性留在内部，而对外简化了接口。路由的处理函数，以及将要实现的中间件，参数都同意使用Context实例，Context里面可以找到任何东西。</li>\n</ol></blockquote>\n<p>Context的具体实现</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package gee  \n  \nimport (  \n   &quot;encoding&#x2F;json&quot;  \n   &quot;fmt&quot;   &quot;net&#x2F;http&quot;)  \n  \n&#x2F;&#x2F; 别名，方便后面调用JSON  \ntype H map[string]interface&#123;&#125;  \n  \n&#x2F;&#x2F; 上下文结构体，暂时存放http.ResponseWriter和*http.Request以及几个常用  \ntype Context struct &#123;  \n   Writer     http.ResponseWriter  \n   Req        *http.Request  \n   Path       string  \n   Method     string  \n   StatusCode int  \n&#125;  \n  \n&#x2F;&#x2F; 新建一个上下文，将几个数据联立起来  \nfunc newContext(w http.ResponseWriter, req *http.Request) *Context &#123;  \n   return &amp;Context&#123;  \n      Writer: w,  \n      Req:    req,  \n      Path:   req.URL.Path,  \n      Method: req.Method,  \n   &#125;  \n&#125;  \n  \n&#x2F;&#x2F; 访问键值，如果有必要，FormValue会调用ParseMultipartFrom和ParseForm，并忽略这些函数所返回的任何错误。  \n&#x2F;&#x2F; 如果键不存在，返回一个空字符串。  \nfunc (c *Context) PostForm(key string) string &#123;  \n   return c.Req.FormValue(key)  \n&#125;  \n  \n&#x2F;&#x2F; URL是一个结构体，Query是他的特有函数，会返回一个map，Get是map的特有函数。总的是获取键值  \nfunc (c *Context) Query(key string) string &#123;  \n   return c.Req.URL.Query().Get(key)  \n&#125;  \n  \n&#x2F;&#x2F; 更新状态码，并写入返回报文  \nfunc (c *Context) Status(code int) &#123;  \n   c.StatusCode &#x3D; code  \n   c.Writer.WriteHeader(code)  \n&#125;  \n  \n&#x2F;&#x2F; Header返回的是一个map，然后调用一系列函数，设置map的值  \nfunc (c *Context) SetHeader(key string, value string) &#123;  \n   c.Writer.Header().Set(key, value)  \n&#125;  \n  \n&#x2F;&#x2F; 将数据写入到返回报文，values是一个多元素传参，将其并且展开，在下面调用Write函数写入  \nfunc (c *Context) String(code int, format string, values ...interface&#123;&#125;) &#123;  \n   c.SetHeader(&quot;Content-Type&quot;, &quot;text&#x2F;plain&quot;)  \n   c.Status(code)  \n   c.Writer.Write([]byte(fmt.Sprintf(format, values...)))  \n&#125;  \n  \n&#x2F;&#x2F; 处理JSON格式  \nfunc (c *Context) JSON(code int, obj interface&#123;&#125;) &#123;  \n   c.SetHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;)  \n   c.Status(code)  \n   encoder :&#x3D; json.NewEncoder(c.Writer)  \n   if err :&#x3D; encoder.Encode(obj); err !&#x3D; nil &#123;  \n      http.Error(c.Writer, err.Error(), 500)  \n   &#125;  \n&#125;  \n  \n&#x2F;&#x2F; 写入数据  \nfunc (c *Context) Data(code int, data []byte) &#123;  \n   c.Status(code)  \n   c.Writer.Write(data)  \n&#125;  \n  \n&#x2F;&#x2F; 处理HTML格式  \nfunc (c *Context) HTML(code int, html string) &#123;  \n   c.SetHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html&quot;)  \n   c.Status(code)  \n   c.Writer.Write([]byte(html))  \n&#125;</code></pre>\n<ul>\n<li>代码开头，给map起一个别名H，使其用法和gin类似，方便后面使用，构建JSOn函数时，显得更简洁。</li>\n<li>Context目前值包含了<code>http.ResponseWriter</code>和 <code>*http.Request</code>，另外提供了对Method和Path这两个常用属性的直接访问。</li>\n<li>提供了访问Query和PostForm参数的方法（注释中有写）</li>\n<li>提供了快速构造String/Data/JSON/HTML响应的方法<h3 id=\"路由（Router）\"><a href=\"#路由（Router）\" class=\"headerlink\" title=\"路由（Router）\"></a>路由（Router）</h3>我们将和路由相关的结构提取出来，放到一个新的文件中，方便下一次对router的功能进行增强，例如提供动态路由的支持，router和handle方法作了一个细微的调整，即handler的参数，变成了Context。<br>Router的具体实现<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package gee  \n  \nimport (  \n   &quot;log&quot;  \n   &quot;net&#x2F;http&quot;)  \n  \n&#x2F;&#x2F; 声明一个路由结构体  \ntype router struct &#123;  \n   handlers map[string]HandlerFunc  \n&#125;  \n  \nfunc newRouter() *router &#123;  \n   return &amp;router&#123;handlers: make(map[string]HandlerFunc)&#125;  \n&#125;  \n  \n&#x2F;&#x2F; 添加路由  \nfunc (r *router) addRoute(method string, pattern string, handler HandlerFunc) &#123;  \n   log.Printf(&quot;Route %4s - %4s&quot;, method, pattern)  \n   key :&#x3D; method + &quot;-&quot; + pattern  \n   r.handlers[key] &#x3D; handler  \n&#125;  \n  \n&#x2F;&#x2F; 处理路由  \nfunc (r *router) handle(c *Context) &#123;  \n   key :&#x3D; c.Method + &quot;-&quot; + c.Path  \n   if handler, ok :&#x3D; r.handlers[key]; ok &#123;  \n      handler(c)  \n   &#125; else &#123;  \n      c.String(http.StatusNotFound, &quot;404 NOT FOUND: %s\\n&quot;, c.Path)  \n   &#125;  \n&#125;</code></pre></li>\n</ul>\n<p>可以理解为这里面的更偏向底层函数，在gee.go中会有函数反复调用上面的函数。</p>\n<h3 id=\"框架入口\"><a href=\"#框架入口\" class=\"headerlink\" title=\"框架入口\"></a>框架入口</h3><p>gee.go具体实现</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package gee  \n  \nimport (  \n   &quot;net&#x2F;http&quot;  \n)  \n  \n&#x2F;&#x2F; 声明函数类型，稍后作为路由map的val  \ntype HandlerFunc func(*Context)  \n  \n&#x2F;&#x2F; 声明一个结构体，为实例的结构，内部包含一个路由表，用map实现  \ntype Engine struct &#123;  \n   router *router  \n&#125;  \n  \n&#x2F;&#x2F; 初始化一个对象，即初始化一个结构体  \nfunc New() *Engine &#123;  \n   return &amp;Engine&#123;router: newRouter()&#125;  \n&#125;  \n  \n&#x2F;&#x2F; 添加一个路由  \nfunc (engine *Engine) addRoute(method string, pattren string, handler HandlerFunc) &#123;  \n   engine.router.addRoute(method, pattren, handler)  \n&#125;  \n  \n&#x2F;&#x2F; 添加GET  \nfunc (engine *Engine) GET(pattern string, handler HandlerFunc) &#123;  \n   engine.addRoute(&quot;GET&quot;, pattern, handler)  \n&#125;  \n  \n&#x2F;&#x2F; 添加POST  \nfunc (engine *Engine) POST(pattern string, handler HandlerFunc) &#123;  \n   engine.addRoute(&quot;POST&quot;, pattern, handler)  \n&#125;  \n  \n&#x2F;&#x2F; 开启web服务，其实就是调用标准库的http.ListenAndServe函数，使用下面的  \nfunc (engine *Engine) Run(addr string) (err error) &#123;  \n   &#x2F;&#x2F; 用实例开启web服务  \n   return http.ListenAndServe(addr, engine)  \n&#125;  \n  \n&#x2F;&#x2F; 用这两个参数，构建一个Context，然后在路由表中去寻找  \nfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;  \n   c :&#x3D; newContext(w, req)  \n   engine.router.handle(c)  \n&#125;</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>将router相关代码独立之后，<code>gee.go</code>简单了不少。ServerHTTP接口接管了所有的HTTP请求，相比第一天的代码，这个方法也有细微的调整，在调用router.handle之前，构造了一个Context对象。这个对象目前还非常简单，仅仅是包装了原来的两个参数。</p></blockquote>\n","text":" 将路由（router）独立出来，方便之后增强 设计上下文（Context），封装Request和Response，提供对JSON、HTML等返回类型的支持 设计Context 对于web服务器来说，无非是根据请求http。Request，构造响应http.ResponseWri...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Gee","slug":"Gee","count":6,"path":"api/tags/Gee.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1Context\"><span class=\"toc-text\">设计Context</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1%EF%BC%88Router%EF%BC%89\"><span class=\"toc-text\">路由（Router）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A1%86%E6%9E%B6%E5%85%A5%E5%8F%A3\"><span class=\"toc-text\">框架入口</span></a></li></ol>","author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}},"mapped":true,"prev_post":{"title":"前缀树路由","uid":"f614bbeabacde0e4aaa0d731d128996c","slug":"前缀树路由","date":"2022-12-02T16:09:02.000Z","updated":"2022-12-03T08:09:01.870Z","comments":true,"path":"api/articles/前缀树路由.json","keywords":"kuan525","cover":null,"text":" 使用trie树实现动态路由解析 支持两种模式，:name和*filepath Trie树实现 Trie树不多说了，结点树，始终每个节点存放一截字符串（网址）嵌入两种模式，则在每个节点处增加一个判断即可 节点结构体 type node struct &#123; pattern ...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Gee","slug":"Gee","count":6,"path":"api/tags/Gee.json"}],"author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}}},"next_post":{"title":"HTTP基础","uid":"0f078f596417876613c3439a68f4ffb7","slug":"HTTP基础","date":"2022-12-02T05:54:30.000Z","updated":"2022-12-03T08:09:01.867Z","comments":true,"path":"api/articles/HTTP基础.json","keywords":"kuan525","cover":null,"text":"使用net/http使用http.HandleFunc(&quot;路径&quot;, 路由处理函数)来将路由注册到路由表，并且绑定对应的处理函数，可以用map实现。使用http.ListenAndServe(&quot;:端口&quot;, nil)，nil其实是一个实例，由于...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Gee","slug":"Gee","count":6,"path":"api/tags/Gee.json"}],"author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}}}}