{"title":"前缀树路由","uid":"f614bbeabacde0e4aaa0d731d128996c","slug":"前缀树路由","date":"2022-12-02T16:09:02.000Z","updated":"2022-12-03T08:09:01.870Z","comments":true,"path":"api/articles/前缀树路由.json","keywords":"kuan525","cover":null,"content":"<ul>\n<li>使用trie树实现动态路由解析</li>\n<li>支持两种模式，<code>:name</code>和<code>*filepath</code> <h3 id=\"Trie树实现\"><a href=\"#Trie树实现\" class=\"headerlink\" title=\"Trie树实现\"></a>Trie树实现</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Trie树不多说了，结点树，始终每个节点存放一截字符串（网址）<br>嵌入两种模式，则在每个节点处增加一个判断即可</p></blockquote>\n</li>\n</ul>\n<p>节点结构体</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type node struct &#123;  \n\tpattern  string &#x2F;&#x2F; 待匹配路由，例如 &#x2F;p&#x2F;:lang  \n\tpart     string &#x2F;&#x2F; 路由中的一部分，例如 :lang  \n\tchildren []*node &#x2F;&#x2F; 子节点，例如 [doc, tutorial, intro]  \n\tisWild   bool &#x2F;&#x2F; 是否精确匹配，part 含有 : 或 * 时为true  \n&#125;</code></pre>\n<p>两个辅助函数</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 第一个匹配成功的节点，用于插入  \nfunc (n *node) matchChild(part string) *node &#123;  \n\tfor _, child :&#x3D; range n.children &#123;  \n\t\tif child.part &#x3D;&#x3D; part || child.isWild &#123;  \n\t\t\treturn child  \n\t\t&#125;  \n\t&#125;  \n\treturn nil  \n&#125;  \n&#x2F;&#x2F; 所有匹配成功的节点，用于查找  \nfunc (n *node) matchChildren(part string) []*node &#123;  \n\tnodes :&#x3D; make([]*node, 0)  \n\tfor _, child :&#x3D; range n.children &#123;  \n\t\tif child.part &#x3D;&#x3D; part || child.isWild &#123;  \n\t\t\tnodes &#x3D; append(nodes, child)  \n\t\t&#125;  \n\t&#125;  \n\treturn nodes  \n&#125;</code></pre>\n<p>插入与查找函数</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func (n *node) insert(pattern string, parts []string, height int) &#123;  \n\tif len(parts) &#x3D;&#x3D; height &#123;  \n\t\tn.pattern &#x3D; pattern  \n\t\treturn  \n\t&#125;  \n  \n\tpart :&#x3D; parts[height]  \n\tchild :&#x3D; n.matchChild(part)  \n\tif child &#x3D;&#x3D; nil &#123;  \n\t\tchild &#x3D; &amp;node&#123;part: part, isWild: part[0] &#x3D;&#x3D; &#39;:&#39; || part[0] &#x3D;&#x3D; &#39;*&#39;&#125;  \n\t\tn.children &#x3D; append(n.children, child)  \n\t&#125;  \n\tchild.insert(pattern, parts, height+1)  \n&#125;  \n  \nfunc (n *node) search(parts []string, height int) *node &#123;  \n\tif len(parts) &#x3D;&#x3D; height || strings.HasPrefix(n.part, &quot;*&quot;) &#123;  \n\t\tif n.pattern &#x3D;&#x3D; &quot;&quot; &#123;  \n\t\t\treturn nil  \n\t\t&#125;  \n\t\treturn n  \n\t&#125;  \n  \n\tpart :&#x3D; parts[height]  \n\tchildren :&#x3D; n.matchChildren(part)  \n  \n\tfor _, child :&#x3D; range children &#123;  \n\t\tresult :&#x3D; child.search(parts, height+1)  \n\t\tif result !&#x3D; nil &#123;  \n\t\t\treturn result  \n\t\t&#125;  \n\t&#125;  \n  \n\treturn nil  \n&#125;</code></pre>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>需要强调的一点是，在插入的时候，遇到<code>*</code>后面就不会继续插入了，详细可以看代码9行，当里面存在<code>*</code>的时候，<code>child</code>一定不为空，但是又一点需要注意，要是先插入的是非<code>*</code>，再插入一个<code>*</code>的时候，匹配可能就存在一定问题，在子节点append的时候，是有顺序的，所以这里算是一个bug</p></blockquote>\n<h3 id=\"Router\"><a href=\"#Router\" class=\"headerlink\" title=\"Router\"></a>Router</h3><ol>\n<li>修改<code>router</code>结构体，增加一个<code>roots    map[string]*node</code>用来存放不同协议对应的前缀树头节点</li>\n<li>修改<code>router</code>初始化函数</li>\n<li>增加<code>parsePattern</code>函数，删掉<code>*</code>后面的一部分，如果存在的话</li>\n<li>增加<code>(r *router) addRoute</code>函数，解析字符串，加入到前缀树中</li>\n<li>增加<code>(r *router) getRoute</code>函数，找到被替换的那一段，记录在map里面，从被替换的位置开始</li>\n<li>新增trie文件，当中存放插入和删除函数，以及两个辅助函数。</li>\n</ol>\n<h3 id=\"Context与handle的变化\"><a href=\"#Context与handle的变化\" class=\"headerlink\" title=\"Context与handle的变化\"></a>Context与handle的变化</h3><ol>\n<li>我们需要将解析后参数存储起来，也就是改变的路径，所以我们需要将上述介绍到的map存起来，我们存在<code>Context</code>中，就可以很方便的返回，再新建一个<code>Param</code>函数，方便查找 </li>\n<li>修改<code>handle</code>函数，将<code>param</code>加到<code>Context</code>中</li>\n</ol>\n<p>Trie树参考代码：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package gee  \n  \nimport (  \n   &quot;fmt&quot;  \n   &quot;reflect&quot;   &quot;strings&quot;   &quot;testing&quot;)  \n  \n&#x2F;&#x2F; 新建节点  \ntype node struct &#123;  \n   pattern  string  \n   part     string  \n   children []*node  \n   isWild   bool  \n&#125;  \n  \n&#x2F;&#x2F; 找到当前节点的可以匹配的儿子，第一个找到的，所以这里会有问题  \nfunc (n *node) matchChild(part string) *node &#123;  \n   for _, child :&#x3D; range n.children &#123;  \n      if child.part &#x3D;&#x3D; part || child.isWild &#123;  \n         return child  \n      &#125;  \n   &#125;  \n   return nil  \n&#125;  \n  \n&#x2F;&#x2F; 找到所有的儿子  \nfunc (n *node) matchChildren(part string) []*node &#123;  \n   nodes :&#x3D; make([]*node, 0)  \n   for _, child :&#x3D; range n.children &#123;  \n      if child.part &#x3D;&#x3D; part || child.isWild &#123;  \n         nodes &#x3D; append(nodes, child)  \n      &#125;  \n   &#125;  \n   return nodes  \n&#125;  \n  \n&#x2F;&#x2F; 加入连接，这里有*的先加入和后加入会有一定问题  \nfunc (n *node) insert(pattren string, parts []string, height int) &#123;  \n   if len(parts) &#x3D;&#x3D; height &#123;  \n      n.pattern &#x3D; pattren  \n      return  \n   &#125;  \n  \n   part :&#x3D; parts[height]  \n   child :&#x3D; n.matchChild(part)  \n   if child &#x3D;&#x3D; nil &#123;  \n      child &#x3D; &amp;node&#123;part: part, isWild: part[0] &#x3D;&#x3D; &#39;:&#39; || part[0] &#x3D;&#x3D; &#39;*&#39;&#125;  \n      n.children &#x3D; append(n.children, child)  \n   &#125;  \n   child.insert(pattren, parts, height+1)  \n&#125;  \n  \n&#x2F;&#x2F; 查询，并返回匹配到的链接的最后一个节点  \nfunc (n *node) search(parts []string, height int) *node &#123;  \n   fmt.Printf(&quot;%d %s&quot;, height, n.part)  \n   if len(parts) &#x3D;&#x3D; height || strings.HasPrefix(n.part, &quot;*&quot;) &#123;  \n      fmt.Printf(&quot;%s&quot;, n.pattern)  \n      if n.pattern &#x3D;&#x3D; &quot;&quot; &#123;  \n         return nil  \n      &#125;  \n      return n  \n   &#125;  \n  \n   part :&#x3D; parts[height]  \n   children :&#x3D; n.matchChildren(part)  \n  \n   for _, child :&#x3D; range children &#123;  \n      result :&#x3D; child.search(parts, height+1)  \n      if result !&#x3D; nil &#123;  \n         return result  \n      &#125;  \n   &#125;  \n  \n   return nil  \n&#125;  \n  \n&#x2F;&#x2F; trie前缀树单元测试  \nfunc newTestRouter() *router &#123;  \n   r :&#x3D; newRouter()  \n   r.addRoute(&quot;GET&quot;, &quot;&#x2F;&quot;, nil)  \n   r.addRoute(&quot;GET&quot;, &quot;&#x2F;hello&#x2F;:name&quot;, nil)  \n   r.addRoute(&quot;GET&quot;, &quot;&#x2F;hello&#x2F;b&#x2F;c&quot;, nil)  \n   r.addRoute(&quot;GET&quot;, &quot;&#x2F;hi&#x2F;:name&quot;, nil)  \n   r.addRoute(&quot;GET&quot;, &quot;&#x2F;assets&#x2F;*filepath&quot;, nil)  \n   return r  \n&#125;  \n  \nfunc TestParsePattern(t *testing.T) &#123;  \n   ok :&#x3D; reflect.DeepEqual(parsePattern(&quot;&#x2F;p&#x2F;:name&quot;), []string&#123;&quot;p&quot;, &quot;:name&quot;&#125;)  \n   ok &#x3D; ok &amp;&amp; reflect.DeepEqual(parsePattern(&quot;&#x2F;p&#x2F;*&quot;), []string&#123;&quot;p&quot;, &quot;*&quot;&#125;)  \n   ok &#x3D; ok &amp;&amp; reflect.DeepEqual(parsePattern(&quot;&#x2F;p&#x2F;*name&#x2F;*&quot;), []string&#123;&quot;p&quot;, &quot;*name&quot;&#125;)  \n   if !ok &#123;  \n      t.Fatal(&quot;test parsePattern failed&quot;)  \n   &#125; else &#123;  \n      fmt.Printf(&quot;yes:1&quot;)  \n   &#125;  \n&#125;  \n  \nfunc TestGetRoute(t *testing.T) &#123;  \n   r :&#x3D; newTestRouter()  \n   n, ps :&#x3D; r.getRoute(&quot;GET&quot;, &quot;&#x2F;hello&#x2F;geektutu&quot;)  \n  \n   if n &#x3D;&#x3D; nil &#123;  \n      t.Fatal(&quot;nil shouldn&#39;t be returned&quot;)  \n   &#125;  \n  \n   if n.pattern !&#x3D; &quot;&#x2F;hello&#x2F;:name&quot; &#123;  \n      t.Fatal(&quot;should match &#x2F;hello&#x2F;:name&quot;)  \n   &#125;  \n  \n   if ps[&quot;name&quot;] !&#x3D; &quot;geektutu&quot; &#123;  \n      t.Fatal(&quot;name should be equal to &#39;geektutu&#39;&quot;)  \n   &#125;  \n  \n   fmt.Printf(&quot;matched path: %s, params[&#39;name&#39;]: %s\\n&quot;, n.pattern, ps[&quot;name&quot;])  \n  \n&#125;</code></pre>","text":" 使用trie树实现动态路由解析 支持两种模式，:name和*filepath Trie树实现 Trie树不多说了，结点树，始终每个节点存放一截字符串（网址）嵌入两种模式，则在每个节点处增加一个判断即可 节点结构体 type node struct &#123; pattern ...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Gee","slug":"Gee","count":7,"path":"api/tags/Gee.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Trie%E6%A0%91%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">Trie树实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">注意</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Router\"><span class=\"toc-text\">Router</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Context%E4%B8%8Ehandle%E7%9A%84%E5%8F%98%E5%8C%96\"><span class=\"toc-text\">Context与handle的变化</span></a></li></ol>","author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}},"mapped":true,"prev_post":{"title":"分组控制","uid":"825b5ff282f50c9ddf9881510ca01667","slug":"分组控制","date":"2022-12-02T17:39:53.000Z","updated":"2022-12-03T08:09:01.869Z","comments":true,"path":"api/articles/分组控制.json","keywords":"kuan525","cover":null,"text":" 实现路由分组控制分组的意义 分组控制是Web框架应提供的基础功能之一，所谓分组，是指路由的分组，如果没有路由分组，我们需要针对每一个路由进行控制，但是真是的业务场景中，往往某一组路由需要相似的处理，例如 以/post开头的路由匿名可访问 以/admin开头的路由需要鉴权 以ap...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Gee","slug":"Gee","count":7,"path":"api/tags/Gee.json"}],"author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}}},"next_post":{"title":"上下文Context","uid":"cc752e8912b50d572e9477f30896c7fb","slug":"上下文Context","date":"2022-12-02T08:54:00.000Z","updated":"2022-12-03T08:09:01.868Z","comments":true,"path":"api/articles/上下文Context.json","keywords":"kuan525","cover":null,"text":" 将路由（router）独立出来，方便之后增强 设计上下文（Context），封装Request和Response，提供对JSON、HTML等返回类型的支持 设计Context 对于web服务器来说，无非是根据请求http。Request，构造响应http.ResponseWri...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Gee","slug":"Gee","count":7,"path":"api/tags/Gee.json"}],"author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}}}}