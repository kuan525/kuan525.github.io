{"title":"一致性哈希","uid":"9bcc4dbf5fd0afda677727e925c7a91f","slug":"一致性哈希","date":"2022-12-10T03:42:33.000Z","updated":"2022-12-10T03:43:04.430Z","comments":true,"path":"api/articles/一致性哈希.json","keywords":"kuan525","cover":null,"content":"<ul>\n<li>一致性哈希的原理以及为什么要使用一致性哈希</li>\n<li>实现一致性哈希<h3 id=\"为什么使用一致性哈希\"><a href=\"#为什么使用一致性哈希\" class=\"headerlink\" title=\"为什么使用一致性哈希\"></a>为什么使用一致性哈希</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对于分布式缓存来说，当一个节点接收到请求，如果该节点并没有存储缓存值，那么它面临的难题时，从谁那里获取源数据。<br>假设第一次随机选择了节点1，节点1从数据源获取到数据的同时缓存该数据，那第二次只有1/10的几率选择节点1，否则选其他节点，如果选其他节点，就意味着需要再一次从数据源获取数据，一般来说，这个操作是很耗时的，这样做，一是缓存效率低下，二是各个节点上存储着相同的数据，浪费了大量存储空间。<br>使用hash算法能做到这一点，那把key的每一个自负的ASCII码加起来，在除以10取余数可以！但是如果节点数量变化，则可能会引发缓存雪崩。意味着大规模迁徙</p></blockquote>\n</li>\n</ul>\n<h3 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h3><h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><ol>\n<li>一致性哈希算法将key映射到一个大区间里面，将这个区间首尾相连，形成一个环（映射到值域）</li>\n<li>计算节点/机器（通常使用节点的名称、编号和IP地址）的哈希值，放置在环上。</li>\n<li>计算key的哈希值，放在患上，顺时针寻找到的第一个节点，就是应选取的节点/机器<h4 id=\"数据倾斜\"><a href=\"#数据倾斜\" class=\"headerlink\" title=\"数据倾斜\"></a>数据倾斜</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果服务器上的节点过少，容易引起key的倾斜，导致部分节点的压力过大，部分过小，所以需要使用一个办法。</p>\n<ol>\n<li>计算节点的hash值，放在环上</li>\n<li>计算key的hash值，在环上顺时针寻砸后到应选取的虚拟节点（散开）</li>\n<li>记录虚拟节点到真是节点的映射</li>\n</ol></blockquote>\n</li>\n</ol>\n<h3 id=\"GO语言实现\"><a href=\"#GO语言实现\" class=\"headerlink\" title=\"GO语言实现\"></a>GO语言实现</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package consistenthash  \n  \nimport (  \n   &quot;hash&#x2F;crc32&quot;  \n   &quot;sort&quot;   &quot;strconv&quot;)  \n  \ntype Hash func(data []byte) uint32  \n  \ntype Map struct &#123;  \n   hash     Hash           &#x2F;&#x2F; hash函数  \n   replicas int            &#x2F;&#x2F; 虚拟节点倍数  \n   keys     []int          &#x2F;&#x2F; 哈希环  \n   hashMap  map[int]string &#x2F;&#x2F; 虚拟节点与真是节点的映射表  \n&#125;  \n  \n&#x2F;&#x2F; 初始化  \nfunc New(replicas int, fn Hash) *Map &#123;  \n   m :&#x3D; &amp;Map&#123;  \n      replicas: replicas,  \n      hash:     fn,  \n      hashMap:  make(map[int]string),  \n   &#125;  \n  \n   &#x2F;&#x2F; 如果没有自定义Hash函数，默认使用crc32.ChecksumIEEE  \n   if m.hash &#x3D;&#x3D; nil &#123;  \n      m.hash &#x3D; crc32.ChecksumIEEE  \n   &#125;  \n   return m  \n&#125;  \n  \n&#x2F;&#x2F; 新增节点  \nfunc (m *Map) Add(keys ...string) &#123;  \n   for _, key :&#x3D; range keys &#123;  \n      for i :&#x3D; 0; i &lt; m.replicas; i++ &#123; &#x2F;&#x2F; 虚拟节点  \n         hash :&#x3D; int(m.hash([]byte(strconv.Itoa(i) + key))) &#x2F;&#x2F; +key  \n         m.keys &#x3D; append(m.keys, hash)                      &#x2F;&#x2F; 加入环  \n         m.hashMap[hash] &#x3D; key                              &#x2F;&#x2F; 加入映射  \n      &#125;  \n   &#125;  \n   sort.Ints(m.keys) &#x2F;&#x2F; 环排序  \n&#125;  \n  \nfunc (m *Map) Get(key string) string &#123;  \n   if len(m.keys) &#x3D;&#x3D; 0 &#123;  \n      return &quot;&quot;  \n   &#125;  \n  \n   &#x2F;&#x2F; 计算哈希值  \n   hash :&#x3D; int(m.hash([]byte(key)))  \n   &#x2F;&#x2F; 找到第一个匹配的下标  \n   idx :&#x3D; sort.Search(len(m.keys), func(i int) bool &#123;  \n      return m.keys[i] &gt;&#x3D; hash  \n   &#125;)  \n  \n   &#x2F;&#x2F; 找到匹配下表对应的真实节点  \n   return m.hashMap[m.keys[idx%len(m.keys)]]  \n&#125;</code></pre>\n<p>测试代码：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package consistenthash  \n  \nimport (  \n   &quot;fmt&quot;  \n   &quot;strconv&quot;   &quot;testing&quot;)  \n  \nfunc TestHashing(t *testing.T) &#123;  \n   hash :&#x3D; New(3, func(key []byte) uint32 &#123;  \n      i, _ :&#x3D; strconv.Atoi(string(key))  \n      return uint32(i)  \n   &#125;)  \n  \n   hash.Add(&quot;6&quot;, &quot;4&quot;, &quot;2&quot;)  \n  \n   testCases :&#x3D; map[string]string&#123;  \n      &quot;2&quot;:  &quot;2&quot;,  \n      &quot;11&quot;: &quot;2&quot;,  \n      &quot;22&quot;: &quot;4&quot;,  \n      &quot;27&quot;: &quot;2&quot;,  \n   &#125;  \n  \n   for k, v :&#x3D; range testCases &#123;  \n      if hash.Get(k) !&#x3D; v &#123;  \n         t.Errorf(&quot;Asking for %s, should have yielded %s&quot;, k, v)  \n      &#125;  \n   &#125;  \n  \n   hash.Add(&quot;8&quot;)  \n  \n   testCases[&quot;27&quot;] &#x3D; &quot;8&quot;  \n  \n   for k, v :&#x3D; range testCases &#123;  \n      if hash.Get(k) !&#x3D; v &#123;  \n         t.Errorf(&quot;Asking for %s, should have yielded %s&quot;, k, v)  \n      &#125;  \n   &#125;  \n  \n   fmt.Printf(&quot;everything is ok&quot;)  \n&#125;</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果要进行测试，那么我们需要明确得知道每一个传入的key的哈希值，使用默认的<code>crc32.ChecksumIEEE</code>算法显然达不到目的，所以在这里使用了自定义的Hahs算法，自定义的hash算法只处理数字，传入字符串表示的数字，返回对应的数字即可。</p></blockquote>\n<ol>\n<li>一开始，只有2/4/6三个真实节点，对应的虚拟节点的哈希值是02/12/24、04/14/24、06/16/26</li>\n<li>那么用例2/11/23/27选择的虚拟节点分别是02/12/24/02，也就是真实节点2/2/4/2</li>\n<li>添加一个真实节点8，对应虚拟节点的哈希值时08/18/28，此时，用例27对应的虚拟节点是从02变更成为28，即真实节点8</li>\n</ol>\n","feature":true,"text":" 一致性哈希的原理以及为什么要使用一致性哈希 实现一致性哈希为什么使用一致性哈希 对于分布式缓存来说，当一个节点接收到请求，如果该节点并没有存储缓存值，那么它面临的难题时，从谁那里获取源数据。假设第一次随机选择了节点1，节点1从数据源获取到数据的同时缓存该数据，那第二次只有1/1...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"GeeCache","slug":"GeeCache","count":4,"path":"api/tags/GeeCache.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C\"><span class=\"toc-text\">为什么使用一致性哈希</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">算法原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">步骤</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C\"><span class=\"toc-text\">数据倾斜</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GO%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">GO语言实现</span></a></li></ol>","author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"HTTP服务端","uid":"6cfdbde6709cc79c68a7fde666e7baae","slug":"HTTP服务端","date":"2022-12-09T16:42:52.000Z","updated":"2022-12-09T16:43:38.613Z","comments":true,"path":"api/articles/HTTP服务端.json","keywords":"kuan525","cover":null,"text":" 使用GO语言标准库http搭建HTTP Serverhttp标准库 go语言提供了http标准库，可以非常方便的搭建HTTP服务端和客户端，以下我们无论收到什么请求，都返回字符串“Hello, World” package main import ( &quot;log&quo...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"GeeCache","slug":"GeeCache","count":4,"path":"api/tags/GeeCache.json"}],"author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}},"feature":true}}