{"title":"中间件Middleware","uid":"e686c1a4072877da5733e5e099bd4bf0","slug":"中间件Middleware","date":"2022-12-03T07:06:46.000Z","updated":"2022-12-03T08:09:01.869Z","comments":true,"path":"api/articles/中间件Middleware.json","keywords":"kuan525","cover":null,"content":"<ul>\n<li>设计并实现web框架的中间件Middleware机制</li>\n<li>实现通用的Logger中间件，能够记录请求到响应花费的时间<h3 id=\"中间件是什么\"><a href=\"#中间件是什么\" class=\"headerlink\" title=\"中间件是什么\"></a>中间件是什么</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>中间件，简单来说，就是非业务的技术类组件，Web框架本身不可以去理解所有的业务，因而不可以实现所有的功能，因此，框架需要有一个插口，允许用户自己定义功能，嵌入到框架中，仿佛这个功能是原声支持的一样，因此对中间件而言，需要考虑两个比较关键的问题。</p></blockquote>\n</li>\n</ul>\n<ol>\n<li>插入点在哪里？使用框架的人并不关心底层逻辑的具体实现，如果插入点太底层，中间件的逻辑就会很复杂，如果插入点离用户太近，那和用户直接定义一组函数，每次在Handler中手动调用相比就没有太大优势了。</li>\n<li>中间件的输入是什么？中间件的输入，决定了扩展能力，暴露的参数太少，用户发挥的空间有限。<h3 id=\"中间件设计\"><a href=\"#中间件设计\" class=\"headerlink\" title=\"中间件设计\"></a>中间件设计</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Gee的中间件的定义与路由映射的Handler一致，处理的输入是<code>Context</code>对象，插入点是框架接受到请求初始化<code>Context</code>对象之后，允许用户定义的中间件做一些额外的处理，例如日志的记录，以及对<code>Context</code>进行二次加工。另外通过调用<code>(*Context).Next()</code>函数，中间件可以等待用户自定义的Handler处理结束之后，再做一些额外的操作，例如计算机本次处理所用的时间等。即Gee的中间件指出用户在请求被处理的前后，做一些额外的操作。例如以下例子，记录处理时长：</p></blockquote>\n</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func Logger() HandlerFunc &#123;  \n\treturn func(c *Context) &#123;  \n\t\t&#x2F;&#x2F; Start timer  \n\t\tt :&#x3D; time.Now()  \n\t\t&#x2F;&#x2F; Process request  \n\t\tc.Next()  \n\t\t&#x2F;&#x2F; Calculate resolution time  \n\t\tlog.Printf(&quot;[%d] %s in %v&quot;, c.StatusCode, c.Req.RequestURI, time.Since(t))  \n\t&#125;  \n&#125;</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>另外，支持多个中间价，依次进行调用。</p></blockquote>\n<p>我们给Context添加两个参数：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 上下文结构体，暂时存放http.ResponseWriter和*http.Request以及几个常用\ntype Context struct &#123;  \n\t&#x2F;&#x2F; origin objects  \n\tWriter http.ResponseWriter  \n\tReq    *http.Request  \n\t&#x2F;&#x2F; request info  \n\tPath   string  \n\tMethod string  \n\tParams map[string]string  \n\t&#x2F;&#x2F; response info  \n\tStatusCode int  \n\t&#x2F;&#x2F; middleware  \n\thandlers []HandlerFunc  \n\tindex    int  \n&#125;</code></pre>\n<p><code>handlers</code>是指当前上下文所有的中间件，index是指处理到了第几个中间价<br>于是我们需要更新初始化函数：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 新建一个上下文，将几个数据联立起来  \nfunc newContext(w http.ResponseWriter, req *http.Request) *Context &#123;  \n   return &amp;Context&#123;  \n      Path:   req.URL.Path,  \n      Method: req.Method,  \n      Req:    req,  \n      Writer: w,  \n      index:  -1,  \n   &#125;  \n&#125;</code></pre>\n<p>Next实现：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 控制权移交给后面到中间件  \nfunc (c *Context) Next() &#123;  \n   c.index++ &#x2F;&#x2F; 处理到上下文到什么位置  \n   s :&#x3D; len(c.handlers)  \n   for ; c.index &lt; s; c.index++ &#123;  \n      &#x2F;&#x2F; 处理中间件或处理函数，一部分中间件是有Next函数到，所以他会先跳过自己，达到延迟执行到效果  \n      c.handlers[c.index](c)  \n   &#125;  \n&#125;</code></pre>\n\n<p>然后我们要使用中间件，就需要加入中间件：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 添加中间件，虽然这里只添加到了自己到中间件库中，但是当调用ServeHTTP库当时候  \n&#x2F;&#x2F; 会扫描所有当组，找到合适当所有的中间件  \nfunc (group *RouterGroup) Use(middlewares ...HandlerFunc) &#123;  \n   group.middlewares &#x3D; append(group.middlewares, middlewares...)  \n&#125;</code></pre>\n<p>但是我们调用中间件可以做到等待执行，也就是说某个到达某个中间件的时候他可以等待后面所有的中间件做完了，再做自己的，因此我们需要重新实现以下ServeHTTP函数：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 用这两个参数，构建一个Context，然后在路由表中去寻找  \nfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;  \n   var middlerwares []HandlerFunc  \n   for _, group :&#x3D; range engine.group &#123;  \n      if strings.HasPrefix(req.URL.Path, group.prefix) &#123;  \n         middlerwares &#x3D; append(middlerwares, group.middlewares...)  \n      &#125;  \n   &#125;  \n  \n   c :&#x3D; newContext(w, req)  \n   c.handlers &#x3D; middlerwares  \n   &#x2F;&#x2F; 处理当前路由，这里没有马上处理，因为后面还会用到中间件等  \n   engine.router.handle(c)  \n&#125;</code></pre>\n<p>在<code>engine.router.handle(c)</code>函数中，是处理了当前路由，将当前任务放在c.handlers中，然后执行Next函数，开始执行c.handlers中的一系列中间件，当然里面可能存在一些值中间件中也有Next函数的，这几延后执行。在Context中index的初始值是-1，所有进入之后先自增，就到达了0，也就是处理第一个，正确开始。<br>以下是<code>router.handle</code>函数，也就是上面的<code>engine.router.handle()</code>函数：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 处理路由  \nfunc (r *router) handle(c *Context) &#123;  \n   n, params :&#x3D; r.getRoute(c.Method, c.Path)  \n  \n   if n !&#x3D; nil &#123;  \n      c.params &#x3D; params  \n      key :&#x3D; c.Method + &quot;-&quot; + n.pattern  \n      &#x2F;&#x2F; 将该链接的方法加入到Context到中间件handlers中去，等待后续调用  \n      c.handlers &#x3D; append(c.handlers, r.handlers[key])  \n   &#125; else &#123;  \n      c.handlers &#x3D; append(c.handlers, func(c *Context) &#123;  \n         c.String(http.StatusNotFound, &quot;404 NOT FOUND: %s\\n&quot;, c.Path)  \n      &#125;)  \n   &#125;  \n   &#x2F;&#x2F; 控制权先交给下一个中间件  \n   c.Next()  \n&#125;</code></pre>\n<ul>\n<li>handle函数中，将从路由匹配的到的Handler添加到<code>c.handlers</code>列表中，执行<code>c.Next</code></li>\n</ul>\n<p>至此我们所有的有关中间件的修改已经完毕，下面是测试Demo</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main  \n  \nimport (  \n   &quot;gee&quot;  \n   &quot;log&quot;   &quot;net&#x2F;http&quot;   &quot;time&quot;)  \n  \nfunc onlyForV2() gee.HandlerFunc &#123;  \n   return func(c *gee.Context) &#123;  \n      t :&#x3D; time.Now()  \n      &#x2F;&#x2F;c.Next()  \n      c.Fail(500, &quot;Internal Server Error&quot;)  \n      log.Printf(&quot;[%d] %s in %v for group v2&quot;, c.StatusCode, c.Req.RequestURI, time.Since(t))  \n   &#125;  \n&#125;  \n  \nfunc main() &#123;  \n   r :&#x3D; gee.New()  \n  \n   r.Use(gee.Logger())  \n   r.GET(&quot;&#x2F;index&quot;, func(c *gee.Context) &#123;  \n      c.HTML(http.StatusOK, &quot;&lt;h1&gt;kuan525&lt;&#x2F;h1&gt;&quot;)  \n   &#125;)  \n  \n   &#x2F;&#x2F; 所有正常执行v2路由分组的路由，都会执行onlyForV2函数，执行c.Fail函数，并返回信息。  \n   &#x2F;&#x2F; 在我们的Fail函数中，我们手动停止了后面所有的处理，也就直接完成该请求  \n   v2 :&#x3D; r.Group(&quot;&#x2F;v2&quot;)  \n   v2.Use(onlyForV2())  \n   &#123;  \n      v2.GET(&quot;&#x2F;hello&#x2F;:name&quot;, func(c *gee.Context) &#123;  \n         c.String(http.StatusOK, &quot;hello %s, you&#39;re at %s\\n&quot;, c.Param(&quot;name&quot;), c.Path)  \n      &#125;)  \n   &#125;  \n  \n   r.Run(&quot;:9999&quot;)  \n&#125;</code></pre>","feature":true,"text":" 设计并实现web框架的中间件Middleware机制 实现通用的Logger中间件，能够记录请求到响应花费的时间中间件是什么 中间件，简单来说，就是非业务的技术类组件，Web框架本身不可以去理解所有的业务，因而不可以实现所有的功能，因此，框架需要有一个插口，允许用户自己定义功能...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Gee","slug":"Gee","count":7,"path":"api/tags/Gee.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">中间件是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">中间件设计</span></a></li></ol>","author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}},"mapped":true,"prev_post":{"title":"模版Template","uid":"734934c646f4e8af2906c7234a7b150a","slug":"模版Template","date":"2022-12-05T13:30:57.000Z","updated":"2022-12-05T14:31:18.541Z","comments":true,"path":"api/articles/模版Template.json","keywords":"kuan525","cover":null,"text":" 实现静态资源服务 实现HTML模版渲染 在前后端分离的大趋势之下，前后端解藕，优势非常突出。但是有一大问题在于，页面是在客户端渲染的，比如浏览器，这对于爬虫并不友好，google爬虫已经能够爬去渲染后的网页，但是短期内爬取服务端直接渲染的HTML页面仍然是主流。 静态文件（Se...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Gee","slug":"Gee","count":7,"path":"api/tags/Gee.json"}],"author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}},"feature":true},"next_post":{"title":"分组控制","uid":"825b5ff282f50c9ddf9881510ca01667","slug":"分组控制","date":"2022-12-02T17:39:53.000Z","updated":"2022-12-03T08:09:01.869Z","comments":true,"path":"api/articles/分组控制.json","keywords":"kuan525","cover":null,"text":" 实现路由分组控制分组的意义 分组控制是Web框架应提供的基础功能之一，所谓分组，是指路由的分组，如果没有路由分组，我们需要针对每一个路由进行控制，但是真是的业务场景中，往往某一组路由需要相似的处理，例如 以/post开头的路由匿名可访问 以/admin开头的路由需要鉴权 以ap...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Gee","slug":"Gee","count":7,"path":"api/tags/Gee.json"}],"author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}}}}