{"title":"HTTP基础","uid":"0f078f596417876613c3439a68f4ffb7","slug":"HTTP基础","date":"2022-12-02T05:54:30.000Z","updated":"2022-12-02T06:00:59.325Z","comments":true,"path":"api/articles/HTTP基础.json","keywords":"kuan525","cover":null,"content":"<h4 id=\"使用net-http\"><a href=\"#使用net-http\" class=\"headerlink\" title=\"使用net/http\"></a>使用net/http</h4><p>使用<code>http.HandleFunc(&quot;路径&quot;, 路由处理函数)</code>来将路由注册到路由表，并且绑定对应的处理函数，可以用<code>map</code>实现。<br>使用<code>http.ListenAndServe(&quot;:端口&quot;, nil)</code>，<code>nil</code>其实是一个实例，由于我们没有自己实现，所以他这里调用的是标准库的实例。</p>\n<p>在<code>net/http</code>源码中，<code>Handler</code>是一个接口，需要实现方法<code>ServeHTTP</code>，只要传入了任何实现了<code>ServeHTTP</code>接口的实例，所有的HTTP请求，都交给实例处理了。<br><code>net/http</code>源码：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package http  \n  \ntype Handler interface &#123;  \n    ServeHTTP(w ResponseWriter, r *Request)  \n&#125;  \n  \nfunc ListenAndServe(address string, h Handler) error</code></pre>\n\n<h3 id=\"自定义ServeHTTP\"><a href=\"#自定义ServeHTTP\" class=\"headerlink\" title=\"自定义ServeHTTP:\"></a>自定义ServeHTTP:</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main  \n  \nimport (  \n\t&quot;fmt&quot;  \n\t&quot;log&quot;  \n\t&quot;net&#x2F;http&quot;  \n)  \n  \n&#x2F;&#x2F; Engine is the uni handler for all requests  \ntype Engine struct&#123;&#125;  \n  \nfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;  \n\tswitch req.URL.Path &#123;  \n\tcase &quot;&#x2F;&quot;:  \n\t\tfmt.Fprintf(w, &quot;URL.Path &#x3D; %q\\n&quot;, req.URL.Path)  \n\tcase &quot;&#x2F;hello&quot;:  \n\t\tfor k, v :&#x3D; range req.Header &#123;  \n\t\t\tfmt.Fprintf(w, &quot;Header[%q] &#x3D; %q\\n&quot;, k, v)  \n\t\t&#125;  \n\tdefault:  \n\t\tfmt.Fprintf(w, &quot;404 NOT FOUND: %s\\n&quot;, req.URL)  \n\t&#125;  \n&#125;  \n  \nfunc main() &#123;  \n\tengine :&#x3D; new(Engine)  \n\tlog.Fatal(http.ListenAndServe(&quot;:9999&quot;, engine))  \n&#125;</code></pre>\n<ol>\n<li>定义一个空结构体<code>Engine</code>，实现方法<code>ServeHTTP</code>，第二个参数<code>Request</code>包含了改HTTP请求的所有信息，第一个参数可以构造响应（返回）。</li>\n<li><code>main</code>函数中，我们传入的是自己的实例<code>engine</code>，该实例调用<code>ServeHTTP</code>来匹配路由，在之前我们只需要针对某一路由写处理逻辑<code>handler</code>，在实现了<code>Engine</code>之后，我们拦截了所有的HTTP请求，拥有了统一控制入口，在这里我们可以自由定义路由映射规则，也可以统一添加一些处理逻辑，例如日志、异常处理等。<h3 id=\"Gee雏形\"><a href=\"#Gee雏形\" class=\"headerlink\" title=\"Gee雏形\"></a>Gee雏形</h3>代码目录结构<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">gee&#x2F;  \n  |--gee.go  \n  |--go.mod  \nmain.go  \ngo.mod</code></pre>\ngo.mod<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">module Gee  \n  \ngo 1.19  \n  \nrequire gee v0.0.0  \n  \nreplace gee &#x3D;&gt; .&#x2F;gee</code></pre></li>\n</ol>\n<ul>\n<li>使用<code>replace</code>将<code>gee</code>指向<code>./gee</code><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里需要配置一下版本依赖等等，在外面和里面都初始化一下go mod，上面将<code>gee</code>映射到<code>./gee</code>这里是相对路径，需要保证项目结构如上所示<br>main.go</p></blockquote>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main  \n  \nimport (  \n\t&quot;fmt&quot;  \n\t&quot;net&#x2F;http&quot;  \n  \n\t&quot;gee&quot;  \n)  \n  \nfunc main() &#123;  \n\tr :&#x3D; gee.New()  \n\tr.GET(&quot;&#x2F;&quot;, func(w http.ResponseWriter, req *http.Request) &#123;  \n\t\tfmt.Fprintf(w, &quot;URL.Path &#x3D; %q\\n&quot;, req.URL.Path)  \n\t&#125;)  \n  \n\tr.GET(&quot;&#x2F;hello&quot;, func(w http.ResponseWriter, req *http.Request) &#123;  \n\t\tfor k, v :&#x3D; range req.Header &#123;  \n\t\t\tfmt.Fprintf(w, &quot;Header[%q] &#x3D; %q\\n&quot;, k, v)  \n\t\t&#125;  \n\t&#125;)  \n  \n\tr.Run(&quot;:9999&quot;)  \n&#125;</code></pre>\n使用<code>New()</code>来初始化<code>gee</code>的实例，使用<code>GET()</code>方法添加路由，最后使用<code>Run()</code>来启动服务，这里和<code>gin</code>框架类似，其实都差不多。关于gee的所有函数，都是自己实现。<h3 id=\"gee-go实现\"><a href=\"#gee-go实现\" class=\"headerlink\" title=\"gee.go实现\"></a>gee.go实现</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package gee  \n  \nimport (  \n   &quot;fmt&quot;  \n   &quot;net&#x2F;http&quot;)  \n  \n&#x2F;&#x2F; 声明函数类型，稍后作为路由map的val  \ntype HandlerFunc func(http.ResponseWriter, *http.Request)  \n  \n&#x2F;&#x2F; 声明一个结构体，为实例的结构，内部包含一个路由表，用map实现  \ntype Engine struct &#123;  \n   router map[string]HandlerFunc  \n&#125;  \n  \n&#x2F;&#x2F; 初始化一个对象，即初始化一个结构体  \nfunc New() *Engine &#123;  \n   return &amp;Engine&#123;router: make(map[string]HandlerFunc)&#125;  \n&#125;  \n  \n&#x2F;&#x2F; 添加一个路由  \nfunc (engine *Engine) addRoute(method string, pattren string, handler HandlerFunc) &#123;  \n   &#x2F;&#x2F; 拼接，方法+&quot;-&quot;+路由  \n   key :&#x3D; method + &quot;-&quot; + pattren  \n   &#x2F;&#x2F; 当前key添加他自己的处理函数  \n   engine.router[key] &#x3D; handler  \n&#125;  \n  \n&#x2F;&#x2F; 添加GET  \nfunc (engine *Engine) GET(pattern string, handler HandlerFunc) &#123;  \n   engine.addRoute(&quot;GET&quot;, pattern, handler)  \n&#125;  \n  \n&#x2F;&#x2F; 添加POST  \nfunc (engine *Engine) POST(pattern string, handler HandlerFunc) &#123;  \n   engine.addRoute(&quot;POST&quot;, pattern, handler)  \n&#125;  \n  \n&#x2F;&#x2F; 开启web服务，其实就是调用标准库的http.ListenAndServe函数，使用下面的  \nfunc (engine *Engine) Run(addr string) (err error) &#123;  \n   &#x2F;&#x2F; 用实例开启web服务  \n   return http.ListenAndServe(addr, engine)  \n&#125;  \n  \n&#x2F;&#x2F; 在标准库http.ListenAndServe中，第二个参数为nil或者自建的engine  \n&#x2F;&#x2F; http.ListenAndServe函数都会调用该对象的ServeHTTP函数  \n&#x2F;&#x2F; http标准库  \n&#x2F;&#x2F; package http  \n&#x2F;&#x2F;  \n&#x2F;&#x2F; type Handler interface &#123;  \n&#x2F;&#x2F;    ServeHTTP(w ResponseWriter, r *Request)  \n&#x2F;&#x2F; &#125;  \n&#x2F;&#x2F;  \n&#x2F;&#x2F; func ListenAndServe(address string, h Handler) error  \nfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;  \n   key :&#x3D; req.Method + &quot;-&quot; + req.URL.Path  \n   if handler, ok :&#x3D; engine.router[key]; ok &#123;  \n      &#x2F;&#x2F; handler是处理函数  \n      handler(w, req)  \n   &#125; else &#123;  \n      fmt.Fprintf(w, &quot;404 NOT FOUND: %s\\n&quot;, req.URL)  \n   &#125;  \n&#125;</code></pre></li>\n<li>定义了<code>HandlerFunc</code>，这是提供给框架用户的，用来定义路由映射的处理方法，在<code>Engine</code>中，添加了一种路由映射表，属于<strong>静态路由</strong></li>\n<li>当用户调用<code>(*Engine).GET()</code>方法时，回将路由和处理方法注册到映射表router中，<code>(*Engine).Run()</code>方法，是<code>ListenServe</code>到包装。</li>\n<li><code>Engine</code>实现到<code>ServeHTTP</code>方法的作用就是，解析请求的路径，查找路由映射表，如果找到就执行对应方法（val值），如果找不到就返回404</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Gee框架的原型如上，实现了路由映射表，提供了用户注册静态路由的方法，包装了启动服务的函数。当前我们还没有标准库<code>net/http</code>其余强大的功能，在后面会实现<strong>动态路由</strong>、<strong>中间件</strong>功能</p></blockquote>\n","text":"使用net/http使用http.HandleFunc(&quot;路径&quot;, 路由处理函数)来将路由注册到路由表，并且绑定对应的处理函数，可以用map实现。使用http.ListenAndServe(&quot;:端口&quot;, nil)，nil其实是一个实例，由于...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Gee","slug":"Gee","count":4,"path":"api/tags/Gee.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8net-http\"><span class=\"toc-text\">使用net&#x2F;http</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89ServeHTTP\"><span class=\"toc-text\">自定义ServeHTTP:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Gee%E9%9B%8F%E5%BD%A2\"><span class=\"toc-text\">Gee雏形</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gee-go%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">gee.go实现</span></a>","author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}},"mapped":true,"prev_post":{"title":"上下文Context","uid":"cc752e8912b50d572e9477f30896c7fb","slug":"上下文Context","date":"2022-12-02T08:54:00.000Z","updated":"2022-12-02T08:57:00.475Z","comments":true,"path":"api/articles/上下文Context.json","keywords":"kuan525","cover":null,"text":" 将路由（router）独立出来，方便之后增强 设计上下文（Context），封装Request和Response，提供对JSON、HTML等返回类型的支持 设计Context 对于web服务器来说，无非是根据请求http。Request，构造响应http.ResponseWri...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Gee","slug":"Gee","count":4,"path":"api/tags/Gee.json"}],"author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}},"feature":true},"next_post":{"title":"线性dp问题","uid":"f390a0a8b566878fd44aa08498486b1a","slug":"线性dp问题","date":"2022-12-01T14:17:22.000Z","updated":"2022-12-01T14:20:31.498Z","comments":true,"path":"api/articles/线性dp问题.json","keywords":"kuan525","cover":null,"text":"数字三角形模型【摘花生】: 状态表示：f[i][j]：从左上角到当前点的最大价值 状态属性：max &gt;f[i][j] &#x3D; max(f[i-1][j], f[i][j-1]) + q[i]; 【最低通行费】 状态表示：f[i][j]：从左上角到当前点的最小花费 状态...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","count":2,"path":"api/tags/Algorithm.json"}],"author":{"name":"kuan525","slug":"blog-author","avatar":"https://s3.uuu.ovh/imgs/2022/12/01/7e58bc65f0f1b81a.jpg","link":"/","description":"24ng @weixin:kuan_525","socials":{"github":"https://github.com/kuan525","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xiao-sheng-xiao-meng-1","csdn":"https://blog.csdn.net/m0_53025874","juejin":"https://juejin.cn/user/638157299124168","customs":{}}}}}