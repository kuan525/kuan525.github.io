[{"id":"c641698123cd1e90bb25dbd165f925c7","title":"错误恢复","content":"\n实现错误处理机制panic\n\n\n\n\n\n\n\n\ngo语言中，比较常见的错误处理方法是返回error，由调用者决定后续如何处理。但是如果是无法恢复的错误，也可以手动触发panic，当然如果在程序运行过程中出现了类似的数组越界的错误，panic也会被触发。panic会终止当前执行的程序，退出。\n\n\ndefer\n\n\n\n\n\n\n\n\npanic会导致程序被终止，但是在推出之前，会处理完当前协程上已经defer的任务，效果类似于java语言的try...catch可以defer多个任务，在同一个函数defer多个任务，会逆序执行，即先执行最后defer的任务。在这里，defer的任务执行完成之后，panic还会继续被抛出，导致程序非正常结束。\nrecover\n\n\n\n\n\n\n\n\ngo语言还提供了recover函数，可以避免因为panic发生而导致整个程序终止，recover函数只在defer中生效。\n&#x2F;&#x2F; hello.go  \nfunc test_recover() &#123;  \n\tdefer func() &#123;  \n\t\tfmt.Println(&quot;defer func&quot;)  \n\t\tif err :&#x3D; recover(); err !&#x3D; nil &#123;  \n\t\t\tfmt.Println(&quot;recover success&quot;)  \n\t\t&#125;  \n\t&#125;()  \n  \n\tarr :&#x3D; []int&#123;1, 2, 3&#125;  \n\tfmt.Println(arr[4])  \n\tfmt.Println(&quot;after panic&quot;)  \n&#125;  \n  \nfunc main() &#123;  \n\ttest_recover()  \n\tfmt.Println(&quot;after recover&quot;)  \n&#125;\n有以下运行结果：\n$ go run hello.go   \ndefer func  \nrecover success  \nafter recover\n\n\n\n\n\n\n\n\n\nrecover捕获了panic，程序正常结束。test_recover()中的after panic没有打印，这是正确的，当panic被触发时，控制权就被交给了defer。而在main中打印了after recover，说明程序已经恢复正常，继续往下执行直到结束。\nGee的错误处理机制\n\n\n\n\n\n\n\n\n对于一个Web框架来说，错误处理机制是非常必要的，可是框架本身没有完备的测试，导致在某些情况下出现空指针异常等情况，也有可能用户不正确的参数，触发了某些异常，例如数组越界，空指针等。如果因为这些原因导致系统宕机，必然是不可接受的。我们将在gee中添加一个非常简单的错误处理机制，即在此类错误发生时，像用户返回Internal Server Error，并在日志中打印必要的错误信息，方便进行错误定位。我们之前实现了中间件机制，错误处理也可以作为一个中间件，增强gee框架的能力。我们实现一个Recovery，使用defer挂在上错误恢复的函数，在这个函数中调用recover()，捕获panic，并且讲堆栈信息打印在日志中，像用户返回Internal Server Error。\n 代码如下，详细见注释： gee/recovery.go\n func trace(message string) string &#123;  \n   var pcs [32]uintptr  \n   &#x2F;&#x2F; 调用该函数，返回栈的程序计数器，第0个Caller是Callers本身，第1个是上一层的trace  \n   &#x2F;&#x2F; 第2个是在上一层第defer func。因此，为了简洁一点， 我们直接跳过前三个  \n   n :&#x3D; runtime.Callers(3, pcs[:])  \n  \n   var str strings.Builder  \n   str.WriteString(message + &quot;\\nTraceback:&quot;)  \n   for _, pc :&#x3D; range pcs[:n] &#123;  \n      &#x2F;&#x2F; 获得对应的函数  \n      fn :&#x3D; runtime.FuncForPC(pc)  \n      &#x2F;&#x2F; 通过以下获取到调用该函数到文件名和行号，打印在日志中  \n      file, line :&#x3D; fn.FileLine(pc)  \n      str.WriteString(fmt.Sprintf(&quot;\\n\\t%s:%d&quot;, file, line))  \n   &#125;  \n   return str.String()  \n&#125;  \n  \nfunc Recovery() HandlerFunc &#123;  \n   return func(c *Context) &#123;  \n      defer func() &#123;  \n         if err :&#x3D; recover(); err !&#x3D; nil &#123;  \n            message :&#x3D; fmt.Sprintf(&quot;%s&quot;, err)  \n            log.Printf(&quot;%s\\n\\n&quot;, trace(message))  \n            c.Fail(http.StatusInternalServerError, &quot;Internal Server Error&quot;)  \n         &#125;  \n      &#125;()  \n      c.Next()  \n   &#125;  \n&#125;\n\n\n\n\n\n\n\n\n\n我们在使用gee框架的时候，我们可以在程序开头使用gee.Default函数，这个函数和New函数的区别在于，该函数时New的封装，他多挂载了Logger和Recovery两个中间件\nfunc Default() *Engine &#123;  \n   engine :&#x3D; New()  \n   engine.Use(Logger(), Recovery())  \n   return engine  \n&#125;\n\n\n\n\n\n\n\n\n\n最后进行测试，先访问主页，在访问一个有BUG的页面，服务正常返回，接下来我们再一次成功访问了主页，说明服务完全运转正常。\nmain\npackage main  \n  \nimport (  \n\t&quot;net&#x2F;http&quot;  \n  \n\t&quot;gee&quot;  \n)\n\nfunc main() &#123;  \n\tr :&#x3D; gee.Default()  \n\tr.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;  \n\t\tc.String(http.StatusOK, &quot;Hello Geektutu\\n&quot;)  \n\t&#125;)  \n\t&#x2F;&#x2F; index out of range for testing Recovery()  \n\tr.GET(&quot;&#x2F;panic&quot;, func(c *gee.Context) &#123;  \n\t\tnames :&#x3D; []string&#123;&quot;geektutu&quot;&#125;  \n\t\tc.String(http.StatusOK, names[100])  \n\t&#125;)  \n  \n\tr.Run(&quot;:9999&quot;)  \n&#125;\n运行有：\n&#96;&#96;&#96;\n&#96;&#96;&#96;go\n$ curl &quot;http:&#x2F;&#x2F;localhost:9999&quot;  \nHello Geektutu  \n$ curl &quot;http:&#x2F;&#x2F;localhost:9999&#x2F;panic&quot;  \n&#123;&quot;message&quot;:&quot;Internal Server Error&quot;&#125;  \n$ curl &quot;http:&#x2F;&#x2F;localhost:9999&quot;  \nHello Geektutu","slug":"错误恢复","date":"2022-12-06T07:42:59.000Z","categories_index":"","tags_index":"Gee","author_index":"kuan525"},{"id":"734934c646f4e8af2906c7234a7b150a","title":"模版Template","content":"\n实现静态资源服务\n实现HTML模版渲染\n\n\n\n\n\n\n\n\n在前后端分离的大趋势之下，前后端解藕，优势非常突出。但是有一大问题在于，页面是在客户端渲染的，比如浏览器，这对于爬虫并不友好，google爬虫已经能够爬去渲染后的网页，但是短期内爬取服务端直接渲染的HTML页面仍然是主流。\n\n\n静态文件（Serve Static Files）\n\n\n\n\n\n\n\n\n如果我们将所有的静态文件放在/usr/web那filpath的值即是该目录下文件的相对地址，映射到真实的文件后，将文件返回，静态服务器就实现了。找到文件后，如何返回这一步，net/http库已经实现了。因此，gee框架要做的，仅仅是解析请求的地址，映射到服务器上文件的真实地址，交给http.FileServer处理就好了\n所以我们的解析请求的地址由下面实现（不太懂，大概知道是干嘛的）\n&#x2F;&#x2F; 生成一个handler函数  \nfunc (group *RouterGroup) CreateStaticHandler(relativePath string, fs http.FileSystem) HandlerFunc &#123;  \n   &#x2F;&#x2F; 当前分组前缀+映射地址  \n   absolutePath :&#x3D; path.Join(group.prefix, relativePath)  \n   &#x2F;&#x2F; 当前总映射地址，映射到到主机源地址  \n   fileServer :&#x3D; http.StripPrefix(absolutePath, http.FileServer(fs))  \n   return func(c *Context) &#123;  \n      &#x2F;&#x2F; 取出  \n      file :&#x3D; c.Param(&quot;filepath&quot;)  \n      if _, err :&#x3D; fs.Open(file); err !&#x3D; nil &#123;  \n         c.Status(http.StatusNotFound)  \n         return  \n      &#125;  \n  \n      fileServer.ServeHTTP(c.Writer, c.Req)  \n   &#125;  \n&#125;\n\n&#x2F;&#x2F; 映射，路由relativePath，真是地址是root  \nfunc (group *RouterGroup) Static(relativePath string, root string) &#123;  \n   &#x2F;&#x2F; 获得当前链接的处理函数  \n   handler :&#x3D; group.CreateStaticHandler(relativePath, http.Dir(root))  \n   &#x2F;&#x2F; 获取当前链接的（索引链接）  \n   urlPattern :&#x3D; path.Join(relativePath, &quot;&#x2F;*filepath&quot;)  \n  \n   &#x2F;&#x2F; 当前链接和当前处理函数去处理，添加路由  \n   group.GET(urlPattern, handler)  \n&#125;  \n  \nfunc (engine *Engine) SetFuncMap(funcMap template.FuncMap) &#123;  \n   engine.funcMap &#x3D; funcMap  \n&#125;\n\n\n\n\n\n\n\n\n\n最终使用方式如下所示：\nr :&#x3D; gee.New()  \nr.Static(&quot;&#x2F;assets&quot;, &quot;&#x2F;usr&#x2F;geektutu&#x2F;blog&#x2F;static&quot;)  \n&#x2F;&#x2F; 或相对路径 r.Static(&quot;&#x2F;assets&quot;, &quot;.&#x2F;static&quot;)  \nr.Run(&quot;:9999&quot;)\n\n\n\n\n\n\n\n\n\n用户访问localhost:9999/assets/js/geektutu.js，最终返回/usr/geektutu/blog/static/js/geektutu.js。\nHTML模版渲染\n\n\n\n\n\n\n\n\nGO语言内置了text/template和html/template2个模版标准库。其中html/template为HTML提供了较为完整的支持，包括普通变量渲染、列表渲染、对象渲染等。gee框架等模版渲染直接使用了html/template提供等能力。\n\n为Engine示例添加*template.Template和template.FuncMap对象，前者将所有的模版加载进内存，后者是所有的自定义模版渲染函数\n为用户分别提供了自定义渲染函数funcMap和加载模版的方法。\n修改一下Context，需要加入实例\n对原来的( * Context).HTML()方法做了些小修改，使之支持根据模版文件名选择模版进行渲染type Context struct &#123;  \n    &#x2F;&#x2F; ...  \n\t&#x2F;&#x2F; engine pointer  \n\tengine *Engine  \n&#125;  \n  \nfunc (c *Context) HTML(code int, name string, data interface&#123;&#125;) &#123;  \n\tc.SetHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html&quot;)  \n\tc.Status(code)  \n\tif err :&#x3D; c.engine.htmlTemplates.ExecuteTemplate(c.Writer, name, data); err !&#x3D; nil &#123;  \n\t\tc.Fail(500, err.Error())  \n\t&#125;  \n&#125;\n\n\n\n\n\n\n\n\n\n在Context中添加了一个成员成员变量，这样就能通过Context访问Engine中的HTML模版，实例化Context时，还需要给c.engine赋值\n\n\nfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;  \n\t&#x2F;&#x2F; ...  \n\tc :&#x3D; newContext(w, req)  &#x2F;&#x2F;实例化，下面就要给c.engine赋值\n\tc.handlers &#x3D; middlewares  \n\tc.engine &#x3D; engine  \n\tengine.router.handle(c)  \n&#125;\n文件结构\n---gee&#x2F;  \n---static&#x2F;  \n   |---css&#x2F;  \n        |---geektutu.css  \n   |---file1.txt  \n---templates&#x2F;  \n   |---arr.tmpl  \n   |---css.tmpl  \n   |---custom_func.tmpl  \n---main.go\n\n\n\n\n\n\n\n\n\n在main函数中\n\nr.SetFuncMap  设置模版\nr.LoadHTMLGlob  倒入静态文件\nr.Static静态路由映射\n\n","slug":"模版Template","date":"2022-12-05T13:30:57.000Z","categories_index":"","tags_index":"Gee","author_index":"kuan525"},{"id":"e686c1a4072877da5733e5e099bd4bf0","title":"中间件Middleware","content":"\n设计并实现web框架的中间件Middleware机制\n实现通用的Logger中间件，能够记录请求到响应花费的时间中间件是什么\n\n\n\n\n\n\n\n\n中间件，简单来说，就是非业务的技术类组件，Web框架本身不可以去理解所有的业务，因而不可以实现所有的功能，因此，框架需要有一个插口，允许用户自己定义功能，嵌入到框架中，仿佛这个功能是原声支持的一样，因此对中间件而言，需要考虑两个比较关键的问题。\n\n\n\n插入点在哪里？使用框架的人并不关心底层逻辑的具体实现，如果插入点太底层，中间件的逻辑就会很复杂，如果插入点离用户太近，那和用户直接定义一组函数，每次在Handler中手动调用相比就没有太大优势了。\n中间件的输入是什么？中间件的输入，决定了扩展能力，暴露的参数太少，用户发挥的空间有限。中间件设计\n\n\n\n\n\n\n\n\nGee的中间件的定义与路由映射的Handler一致，处理的输入是Context对象，插入点是框架接受到请求初始化Context对象之后，允许用户定义的中间件做一些额外的处理，例如日志的记录，以及对Context进行二次加工。另外通过调用(*Context).Next()函数，中间件可以等待用户自定义的Handler处理结束之后，再做一些额外的操作，例如计算机本次处理所用的时间等。即Gee的中间件指出用户在请求被处理的前后，做一些额外的操作。例如以下例子，记录处理时长：\n\n\nfunc Logger() HandlerFunc &#123;  \n\treturn func(c *Context) &#123;  \n\t\t&#x2F;&#x2F; Start timer  \n\t\tt :&#x3D; time.Now()  \n\t\t&#x2F;&#x2F; Process request  \n\t\tc.Next()  \n\t\t&#x2F;&#x2F; Calculate resolution time  \n\t\tlog.Printf(&quot;[%d] %s in %v&quot;, c.StatusCode, c.Req.RequestURI, time.Since(t))  \n\t&#125;  \n&#125;\n\n\n\n\n\n\n\n\n\n另外，支持多个中间价，依次进行调用。\n我们给Context添加两个参数：\n&#x2F;&#x2F; 上下文结构体，暂时存放http.ResponseWriter和*http.Request以及几个常用\ntype Context struct &#123;  \n\t&#x2F;&#x2F; origin objects  \n\tWriter http.ResponseWriter  \n\tReq    *http.Request  \n\t&#x2F;&#x2F; request info  \n\tPath   string  \n\tMethod string  \n\tParams map[string]string  \n\t&#x2F;&#x2F; response info  \n\tStatusCode int  \n\t&#x2F;&#x2F; middleware  \n\thandlers []HandlerFunc  \n\tindex    int  \n&#125;\nhandlers是指当前上下文所有的中间件，index是指处理到了第几个中间价于是我们需要更新初始化函数：\n&#x2F;&#x2F; 新建一个上下文，将几个数据联立起来  \nfunc newContext(w http.ResponseWriter, req *http.Request) *Context &#123;  \n   return &amp;Context&#123;  \n      Path:   req.URL.Path,  \n      Method: req.Method,  \n      Req:    req,  \n      Writer: w,  \n      index:  -1,  \n   &#125;  \n&#125;\nNext实现：\n&#x2F;&#x2F; 控制权移交给后面到中间件  \nfunc (c *Context) Next() &#123;  \n   c.index++ &#x2F;&#x2F; 处理到上下文到什么位置  \n   s :&#x3D; len(c.handlers)  \n   for ; c.index &lt; s; c.index++ &#123;  \n      &#x2F;&#x2F; 处理中间件或处理函数，一部分中间件是有Next函数到，所以他会先跳过自己，达到延迟执行到效果  \n      c.handlers[c.index](c)  \n   &#125;  \n&#125;\n\n然后我们要使用中间件，就需要加入中间件：\n&#x2F;&#x2F; 添加中间件，虽然这里只添加到了自己到中间件库中，但是当调用ServeHTTP库当时候  \n&#x2F;&#x2F; 会扫描所有当组，找到合适当所有的中间件  \nfunc (group *RouterGroup) Use(middlewares ...HandlerFunc) &#123;  \n   group.middlewares &#x3D; append(group.middlewares, middlewares...)  \n&#125;\n但是我们调用中间件可以做到等待执行，也就是说某个到达某个中间件的时候他可以等待后面所有的中间件做完了，再做自己的，因此我们需要重新实现以下ServeHTTP函数：\n&#x2F;&#x2F; 用这两个参数，构建一个Context，然后在路由表中去寻找  \nfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;  \n   var middlerwares []HandlerFunc  \n   for _, group :&#x3D; range engine.group &#123;  \n      if strings.HasPrefix(req.URL.Path, group.prefix) &#123;  \n         middlerwares &#x3D; append(middlerwares, group.middlewares...)  \n      &#125;  \n   &#125;  \n  \n   c :&#x3D; newContext(w, req)  \n   c.handlers &#x3D; middlerwares  \n   &#x2F;&#x2F; 处理当前路由，这里没有马上处理，因为后面还会用到中间件等  \n   engine.router.handle(c)  \n&#125;\n在engine.router.handle(c)函数中，是处理了当前路由，将当前任务放在c.handlers中，然后执行Next函数，开始执行c.handlers中的一系列中间件，当然里面可能存在一些值中间件中也有Next函数的，这几延后执行。在Context中index的初始值是-1，所有进入之后先自增，就到达了0，也就是处理第一个，正确开始。以下是router.handle函数，也就是上面的engine.router.handle()函数：\n&#x2F;&#x2F; 处理路由  \nfunc (r *router) handle(c *Context) &#123;  \n   n, params :&#x3D; r.getRoute(c.Method, c.Path)  \n  \n   if n !&#x3D; nil &#123;  \n      c.params &#x3D; params  \n      key :&#x3D; c.Method + &quot;-&quot; + n.pattern  \n      &#x2F;&#x2F; 将该链接的方法加入到Context到中间件handlers中去，等待后续调用  \n      c.handlers &#x3D; append(c.handlers, r.handlers[key])  \n   &#125; else &#123;  \n      c.handlers &#x3D; append(c.handlers, func(c *Context) &#123;  \n         c.String(http.StatusNotFound, &quot;404 NOT FOUND: %s\\n&quot;, c.Path)  \n      &#125;)  \n   &#125;  \n   &#x2F;&#x2F; 控制权先交给下一个中间件  \n   c.Next()  \n&#125;\n\nhandle函数中，将从路由匹配的到的Handler添加到c.handlers列表中，执行c.Next\n\n至此我们所有的有关中间件的修改已经完毕，下面是测试Demo\npackage main  \n  \nimport (  \n   &quot;gee&quot;  \n   &quot;log&quot;   &quot;net&#x2F;http&quot;   &quot;time&quot;)  \n  \nfunc onlyForV2() gee.HandlerFunc &#123;  \n   return func(c *gee.Context) &#123;  \n      t :&#x3D; time.Now()  \n      &#x2F;&#x2F;c.Next()  \n      c.Fail(500, &quot;Internal Server Error&quot;)  \n      log.Printf(&quot;[%d] %s in %v for group v2&quot;, c.StatusCode, c.Req.RequestURI, time.Since(t))  \n   &#125;  \n&#125;  \n  \nfunc main() &#123;  \n   r :&#x3D; gee.New()  \n  \n   r.Use(gee.Logger())  \n   r.GET(&quot;&#x2F;index&quot;, func(c *gee.Context) &#123;  \n      c.HTML(http.StatusOK, &quot;&lt;h1&gt;kuan525&lt;&#x2F;h1&gt;&quot;)  \n   &#125;)  \n  \n   &#x2F;&#x2F; 所有正常执行v2路由分组的路由，都会执行onlyForV2函数，执行c.Fail函数，并返回信息。  \n   &#x2F;&#x2F; 在我们的Fail函数中，我们手动停止了后面所有的处理，也就直接完成该请求  \n   v2 :&#x3D; r.Group(&quot;&#x2F;v2&quot;)  \n   v2.Use(onlyForV2())  \n   &#123;  \n      v2.GET(&quot;&#x2F;hello&#x2F;:name&quot;, func(c *gee.Context) &#123;  \n         c.String(http.StatusOK, &quot;hello %s, you&#39;re at %s\\n&quot;, c.Param(&quot;name&quot;), c.Path)  \n      &#125;)  \n   &#125;  \n  \n   r.Run(&quot;:9999&quot;)  \n&#125;","slug":"中间件Middleware","date":"2022-12-03T07:06:46.000Z","categories_index":"","tags_index":"Gee","author_index":"kuan525"},{"id":"825b5ff282f50c9ddf9881510ca01667","title":"分组控制","content":"\n实现路由分组控制分组的意义\n\n\n\n\n\n\n\n\n分组控制是Web框架应提供的基础功能之一，所谓分组，是指路由的分组，如果没有路由分组，我们需要针对每一个路由进行控制，但是真是的业务场景中，往往某一组路由需要相似的处理，例如\n\n以/post开头的路由匿名可访问\n以/admin开头的路由需要鉴权\n以api开头的路由是RESTful接口，可以对接第三方平台，需要三方平台鉴权例如/post是一个分组，post/a和post/b可以是该分组下的字分组。作用在/post分组上的中间件，也都作用在子分组，子分组还可以应用自己特有的中间件例如/admin的分组，可以应用鉴权中间件；/分组应用日志中间件，/是默认的最顶层的分组，也就意味着给所有的路由，即整个框架增加了记录日志的能力。\n\n\n\n我们可以分组嵌套\nv1 :&#x3D; r.Group(&quot;&#x2F;v1&quot;)  \n\t&#123;  \n\t\tv1.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;  \n\t\t\tc.HTML(http.StatusOK, &quot;&lt;h1&gt;Hello Gee&lt;&#x2F;h1&gt;&quot;)  \n\t\t&#125;)  \n  \n\t\tv1.GET(&quot;&#x2F;hello&quot;, func(c *gee.Context) &#123;  \n\t\t\t&#x2F;&#x2F; expect &#x2F;hello?name&#x3D;geektutu  \n\t\t\tc.String(http.StatusOK, &quot;hello %s, you&#39;re at %s\\n&quot;, c.Query(&quot;name&quot;), c.Path)  \n\t\t&#125;)  \n\t&#125;\n一个Group对象需要具备的属性\n\n前缀prefix\n父亲parent\n中间件middlewares\n指针，指向Engine，整个框架所有资源都是Engine统一协调的，那么就可以通过Engine间接的访问各种借口GRoup实现RouterGroup struct &#123;  \n\tprefix      string  \n\tmiddlewares []HandlerFunc &#x2F;&#x2F; support middleware  \n\tparent      *RouterGroup  &#x2F;&#x2F; support nesting  \n\tengine      *Engine       &#x2F;&#x2F; all groups share a Engine instance  \n&#125;\n我们还需要将Engine作为最顶层的分组，也就是说Engine拥有RouterGroup所有的能力。Engine struct &#123;  \n\t*RouterGroup  \n\trouter *router  \n\tgroups []*RouterGroup &#x2F;&#x2F; store all groups  \n&#125;\n然后我们只需要配置好RouterGroup的所有特有函数即可&#x2F;&#x2F; 初始化一个对象，即初始化一个结构体  \nfunc New() *Engine &#123;  \n   engine :&#x3D; &amp;Engine&#123;router: newRouter()&#125;  \n   engine.RouterGroup &#x3D; &amp;RouterGroup&#123;engine: engine&#125;  \n   engine.group &#x3D; []*RouterGroup&#123;engine.RouterGroup&#125;  \n   return engine  \n&#125;  \n  \n&#x2F;&#x2F; 声明一个group的儿子分组  \nfunc (group *RouterGroup) Group(prefix string) *RouterGroup &#123;  \n   engine :&#x3D; group.engine  \n   newGroup :&#x3D; &amp;RouterGroup&#123;  \n      prefix: group.prefix + prefix,  \n      parent: group,  \n      engine: engine,  \n   &#125;  \n   engine.group &#x3D; append(engine.group, newGroup)  \n   return newGroup  \n&#125;  \n  \n&#x2F;&#x2F; 通过分组添加路由  \nfunc (group *RouterGroup) addRoute(method string, comp string, handler HandlerFunc) &#123;  \n   pattern :&#x3D; group.prefix + comp  \n   log.Printf(&quot;Route %4s - %s&quot;, method, pattern)  \n   group.engine.router.addRoute(method, pattern, handler)  \n&#125;  \n  \n&#x2F;&#x2F; 通过分组实现GET请求处理  \nfunc (group *RouterGroup) GET(pattern string, handler HandlerFunc) &#123;  \n   group.addRoute(&quot;GET&quot;, pattern, handler)  \n&#125;  \n  \n&#x2F;&#x2F; 通过分组实现POST请求处理  \nfunc (group *RouterGroup) POST(pattern string, handler HandlerFunc) &#123;  \n   group.addRoute(&quot;POST&quot;, pattern, handler)  \n&#125;\n\n\n\n\n\n\n\n\n\n在RouterGroup特有的addRoute函数中，调用了group.engine.router.addRoute来实现了路由的映射。由于Engine从某种意义上即成了RouterGroup的所有属性和方法，因为(*Engine).engine是指向自己的。这样实现，我们既可以像原来一样添加路由，也可以通过分组添加路由\n\n\n","slug":"分组控制","date":"2022-12-02T17:39:53.000Z","categories_index":"","tags_index":"Gee","author_index":"kuan525"},{"id":"f614bbeabacde0e4aaa0d731d128996c","title":"前缀树路由","content":"\n使用trie树实现动态路由解析\n支持两种模式，:name和*filepath Trie树实现\n\n\n\n\n\n\n\n\nTrie树不多说了，结点树，始终每个节点存放一截字符串（网址）嵌入两种模式，则在每个节点处增加一个判断即可\n\n\n节点结构体\ntype node struct &#123;  \n\tpattern  string &#x2F;&#x2F; 待匹配路由，例如 &#x2F;p&#x2F;:lang  \n\tpart     string &#x2F;&#x2F; 路由中的一部分，例如 :lang  \n\tchildren []*node &#x2F;&#x2F; 子节点，例如 [doc, tutorial, intro]  \n\tisWild   bool &#x2F;&#x2F; 是否精确匹配，part 含有 : 或 * 时为true  \n&#125;\n两个辅助函数\n&#x2F;&#x2F; 第一个匹配成功的节点，用于插入  \nfunc (n *node) matchChild(part string) *node &#123;  \n\tfor _, child :&#x3D; range n.children &#123;  \n\t\tif child.part &#x3D;&#x3D; part || child.isWild &#123;  \n\t\t\treturn child  \n\t\t&#125;  \n\t&#125;  \n\treturn nil  \n&#125;  \n&#x2F;&#x2F; 所有匹配成功的节点，用于查找  \nfunc (n *node) matchChildren(part string) []*node &#123;  \n\tnodes :&#x3D; make([]*node, 0)  \n\tfor _, child :&#x3D; range n.children &#123;  \n\t\tif child.part &#x3D;&#x3D; part || child.isWild &#123;  \n\t\t\tnodes &#x3D; append(nodes, child)  \n\t\t&#125;  \n\t&#125;  \n\treturn nodes  \n&#125;\n插入与查找函数\nfunc (n *node) insert(pattern string, parts []string, height int) &#123;  \n\tif len(parts) &#x3D;&#x3D; height &#123;  \n\t\tn.pattern &#x3D; pattern  \n\t\treturn  \n\t&#125;  \n  \n\tpart :&#x3D; parts[height]  \n\tchild :&#x3D; n.matchChild(part)  \n\tif child &#x3D;&#x3D; nil &#123;  \n\t\tchild &#x3D; &amp;node&#123;part: part, isWild: part[0] &#x3D;&#x3D; &#39;:&#39; || part[0] &#x3D;&#x3D; &#39;*&#39;&#125;  \n\t\tn.children &#x3D; append(n.children, child)  \n\t&#125;  \n\tchild.insert(pattern, parts, height+1)  \n&#125;  \n  \nfunc (n *node) search(parts []string, height int) *node &#123;  \n\tif len(parts) &#x3D;&#x3D; height || strings.HasPrefix(n.part, &quot;*&quot;) &#123;  \n\t\tif n.pattern &#x3D;&#x3D; &quot;&quot; &#123;  \n\t\t\treturn nil  \n\t\t&#125;  \n\t\treturn n  \n\t&#125;  \n  \n\tpart :&#x3D; parts[height]  \n\tchildren :&#x3D; n.matchChildren(part)  \n  \n\tfor _, child :&#x3D; range children &#123;  \n\t\tresult :&#x3D; child.search(parts, height+1)  \n\t\tif result !&#x3D; nil &#123;  \n\t\t\treturn result  \n\t\t&#125;  \n\t&#125;  \n  \n\treturn nil  \n&#125;\n注意\n\n\n\n\n\n\n\n\n需要强调的一点是，在插入的时候，遇到*后面就不会继续插入了，详细可以看代码9行，当里面存在*的时候，child一定不为空，但是又一点需要注意，要是先插入的是非*，再插入一个*的时候，匹配可能就存在一定问题，在子节点append的时候，是有顺序的，所以这里算是一个bug\nRouter\n修改router结构体，增加一个roots    map[string]*node用来存放不同协议对应的前缀树头节点\n修改router初始化函数\n增加parsePattern函数，删掉*后面的一部分，如果存在的话\n增加(r *router) addRoute函数，解析字符串，加入到前缀树中\n增加(r *router) getRoute函数，找到被替换的那一段，记录在map里面，从被替换的位置开始\n新增trie文件，当中存放插入和删除函数，以及两个辅助函数。\n\nContext与handle的变化\n我们需要将解析后参数存储起来，也就是改变的路径，所以我们需要将上述介绍到的map存起来，我们存在Context中，就可以很方便的返回，再新建一个Param函数，方便查找 \n修改handle函数，将param加到Context中\n\nTrie树参考代码：\npackage gee  \n  \nimport (  \n   &quot;fmt&quot;  \n   &quot;reflect&quot;   &quot;strings&quot;   &quot;testing&quot;)  \n  \n&#x2F;&#x2F; 新建节点  \ntype node struct &#123;  \n   pattern  string  \n   part     string  \n   children []*node  \n   isWild   bool  \n&#125;  \n  \n&#x2F;&#x2F; 找到当前节点的可以匹配的儿子，第一个找到的，所以这里会有问题  \nfunc (n *node) matchChild(part string) *node &#123;  \n   for _, child :&#x3D; range n.children &#123;  \n      if child.part &#x3D;&#x3D; part || child.isWild &#123;  \n         return child  \n      &#125;  \n   &#125;  \n   return nil  \n&#125;  \n  \n&#x2F;&#x2F; 找到所有的儿子  \nfunc (n *node) matchChildren(part string) []*node &#123;  \n   nodes :&#x3D; make([]*node, 0)  \n   for _, child :&#x3D; range n.children &#123;  \n      if child.part &#x3D;&#x3D; part || child.isWild &#123;  \n         nodes &#x3D; append(nodes, child)  \n      &#125;  \n   &#125;  \n   return nodes  \n&#125;  \n  \n&#x2F;&#x2F; 加入连接，这里有*的先加入和后加入会有一定问题  \nfunc (n *node) insert(pattren string, parts []string, height int) &#123;  \n   if len(parts) &#x3D;&#x3D; height &#123;  \n      n.pattern &#x3D; pattren  \n      return  \n   &#125;  \n  \n   part :&#x3D; parts[height]  \n   child :&#x3D; n.matchChild(part)  \n   if child &#x3D;&#x3D; nil &#123;  \n      child &#x3D; &amp;node&#123;part: part, isWild: part[0] &#x3D;&#x3D; &#39;:&#39; || part[0] &#x3D;&#x3D; &#39;*&#39;&#125;  \n      n.children &#x3D; append(n.children, child)  \n   &#125;  \n   child.insert(pattren, parts, height+1)  \n&#125;  \n  \n&#x2F;&#x2F; 查询，并返回匹配到的链接的最后一个节点  \nfunc (n *node) search(parts []string, height int) *node &#123;  \n   fmt.Printf(&quot;%d %s&quot;, height, n.part)  \n   if len(parts) &#x3D;&#x3D; height || strings.HasPrefix(n.part, &quot;*&quot;) &#123;  \n      fmt.Printf(&quot;%s&quot;, n.pattern)  \n      if n.pattern &#x3D;&#x3D; &quot;&quot; &#123;  \n         return nil  \n      &#125;  \n      return n  \n   &#125;  \n  \n   part :&#x3D; parts[height]  \n   children :&#x3D; n.matchChildren(part)  \n  \n   for _, child :&#x3D; range children &#123;  \n      result :&#x3D; child.search(parts, height+1)  \n      if result !&#x3D; nil &#123;  \n         return result  \n      &#125;  \n   &#125;  \n  \n   return nil  \n&#125;  \n  \n&#x2F;&#x2F; trie前缀树单元测试  \nfunc newTestRouter() *router &#123;  \n   r :&#x3D; newRouter()  \n   r.addRoute(&quot;GET&quot;, &quot;&#x2F;&quot;, nil)  \n   r.addRoute(&quot;GET&quot;, &quot;&#x2F;hello&#x2F;:name&quot;, nil)  \n   r.addRoute(&quot;GET&quot;, &quot;&#x2F;hello&#x2F;b&#x2F;c&quot;, nil)  \n   r.addRoute(&quot;GET&quot;, &quot;&#x2F;hi&#x2F;:name&quot;, nil)  \n   r.addRoute(&quot;GET&quot;, &quot;&#x2F;assets&#x2F;*filepath&quot;, nil)  \n   return r  \n&#125;  \n  \nfunc TestParsePattern(t *testing.T) &#123;  \n   ok :&#x3D; reflect.DeepEqual(parsePattern(&quot;&#x2F;p&#x2F;:name&quot;), []string&#123;&quot;p&quot;, &quot;:name&quot;&#125;)  \n   ok &#x3D; ok &amp;&amp; reflect.DeepEqual(parsePattern(&quot;&#x2F;p&#x2F;*&quot;), []string&#123;&quot;p&quot;, &quot;*&quot;&#125;)  \n   ok &#x3D; ok &amp;&amp; reflect.DeepEqual(parsePattern(&quot;&#x2F;p&#x2F;*name&#x2F;*&quot;), []string&#123;&quot;p&quot;, &quot;*name&quot;&#125;)  \n   if !ok &#123;  \n      t.Fatal(&quot;test parsePattern failed&quot;)  \n   &#125; else &#123;  \n      fmt.Printf(&quot;yes:1&quot;)  \n   &#125;  \n&#125;  \n  \nfunc TestGetRoute(t *testing.T) &#123;  \n   r :&#x3D; newTestRouter()  \n   n, ps :&#x3D; r.getRoute(&quot;GET&quot;, &quot;&#x2F;hello&#x2F;geektutu&quot;)  \n  \n   if n &#x3D;&#x3D; nil &#123;  \n      t.Fatal(&quot;nil shouldn&#39;t be returned&quot;)  \n   &#125;  \n  \n   if n.pattern !&#x3D; &quot;&#x2F;hello&#x2F;:name&quot; &#123;  \n      t.Fatal(&quot;should match &#x2F;hello&#x2F;:name&quot;)  \n   &#125;  \n  \n   if ps[&quot;name&quot;] !&#x3D; &quot;geektutu&quot; &#123;  \n      t.Fatal(&quot;name should be equal to &#39;geektutu&#39;&quot;)  \n   &#125;  \n  \n   fmt.Printf(&quot;matched path: %s, params[&#39;name&#39;]: %s\\n&quot;, n.pattern, ps[&quot;name&quot;])  \n  \n&#125;","slug":"前缀树路由","date":"2022-12-02T16:09:02.000Z","categories_index":"","tags_index":"Gee","author_index":"kuan525"},{"id":"cc752e8912b50d572e9477f30896c7fb","title":"上下文Context","content":"\n将路由（router）独立出来，方便之后增强\n设计上下文（Context），封装Request和Response，提供对JSON、HTML等返回类型的支持\n\n设计Context\n\n\n\n\n\n\n\n\n\n对于web服务器来说，无非是根据请求http。Request，构造响应http.ResponseWriter。但是这两个对象提供的接口颗粒太细，比如我们要构造一个完整的响应，需要考虑消息头（Header）和消息体（Body），而Header包含了状态码（StatusCode），消息类型（ContentType）等几乎每次请求都需要设置的信息。因此，如果不进行有效的封装，那么框架的用户将需要写出大量重复，繁杂的代码，而且容易出错，针对常用场景，能够高效地构造HTTP响应是一个好的框架必须考虑的点\n针对使用场景，封装*http.Request和http.ResponseWriter的方法，简化相关接口的调用，只是设计Context的原因之一。对于框架来说，还需要支撑额外的功能，例如，将来解析动态路由，或者框架需要中间件。Context随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由Context承载，因此，设计Context结构，扩展性和复杂性留在内部，而对外简化了接口。路由的处理函数，以及将要实现的中间件，参数都同意使用Context实例，Context里面可以找到任何东西。\n\nContext的具体实现\npackage gee  \n  \nimport (  \n   &quot;encoding&#x2F;json&quot;  \n   &quot;fmt&quot;   &quot;net&#x2F;http&quot;)  \n  \n&#x2F;&#x2F; 别名，方便后面调用JSON  \ntype H map[string]interface&#123;&#125;  \n  \n&#x2F;&#x2F; 上下文结构体，暂时存放http.ResponseWriter和*http.Request以及几个常用  \ntype Context struct &#123;  \n   Writer     http.ResponseWriter  \n   Req        *http.Request  \n   Path       string  \n   Method     string  \n   StatusCode int  \n&#125;  \n  \n&#x2F;&#x2F; 新建一个上下文，将几个数据联立起来  \nfunc newContext(w http.ResponseWriter, req *http.Request) *Context &#123;  \n   return &amp;Context&#123;  \n      Writer: w,  \n      Req:    req,  \n      Path:   req.URL.Path,  \n      Method: req.Method,  \n   &#125;  \n&#125;  \n  \n&#x2F;&#x2F; 访问键值，如果有必要，FormValue会调用ParseMultipartFrom和ParseForm，并忽略这些函数所返回的任何错误。  \n&#x2F;&#x2F; 如果键不存在，返回一个空字符串。  \nfunc (c *Context) PostForm(key string) string &#123;  \n   return c.Req.FormValue(key)  \n&#125;  \n  \n&#x2F;&#x2F; URL是一个结构体，Query是他的特有函数，会返回一个map，Get是map的特有函数。总的是获取键值  \nfunc (c *Context) Query(key string) string &#123;  \n   return c.Req.URL.Query().Get(key)  \n&#125;  \n  \n&#x2F;&#x2F; 更新状态码，并写入返回报文  \nfunc (c *Context) Status(code int) &#123;  \n   c.StatusCode &#x3D; code  \n   c.Writer.WriteHeader(code)  \n&#125;  \n  \n&#x2F;&#x2F; Header返回的是一个map，然后调用一系列函数，设置map的值  \nfunc (c *Context) SetHeader(key string, value string) &#123;  \n   c.Writer.Header().Set(key, value)  \n&#125;  \n  \n&#x2F;&#x2F; 将数据写入到返回报文，values是一个多元素传参，将其并且展开，在下面调用Write函数写入  \nfunc (c *Context) String(code int, format string, values ...interface&#123;&#125;) &#123;  \n   c.SetHeader(&quot;Content-Type&quot;, &quot;text&#x2F;plain&quot;)  \n   c.Status(code)  \n   c.Writer.Write([]byte(fmt.Sprintf(format, values...)))  \n&#125;  \n  \n&#x2F;&#x2F; 处理JSON格式  \nfunc (c *Context) JSON(code int, obj interface&#123;&#125;) &#123;  \n   c.SetHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;)  \n   c.Status(code)  \n   encoder :&#x3D; json.NewEncoder(c.Writer)  \n   if err :&#x3D; encoder.Encode(obj); err !&#x3D; nil &#123;  \n      http.Error(c.Writer, err.Error(), 500)  \n   &#125;  \n&#125;  \n  \n&#x2F;&#x2F; 写入数据  \nfunc (c *Context) Data(code int, data []byte) &#123;  \n   c.Status(code)  \n   c.Writer.Write(data)  \n&#125;  \n  \n&#x2F;&#x2F; 处理HTML格式  \nfunc (c *Context) HTML(code int, html string) &#123;  \n   c.SetHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html&quot;)  \n   c.Status(code)  \n   c.Writer.Write([]byte(html))  \n&#125;\n\n代码开头，给map起一个别名H，使其用法和gin类似，方便后面使用，构建JSOn函数时，显得更简洁。\nContext目前值包含了http.ResponseWriter和 *http.Request，另外提供了对Method和Path这两个常用属性的直接访问。\n提供了访问Query和PostForm参数的方法（注释中有写）\n提供了快速构造String/Data/JSON/HTML响应的方法路由（Router）我们将和路由相关的结构提取出来，放到一个新的文件中，方便下一次对router的功能进行增强，例如提供动态路由的支持，router和handle方法作了一个细微的调整，即handler的参数，变成了Context。Router的具体实现package gee  \n  \nimport (  \n   &quot;log&quot;  \n   &quot;net&#x2F;http&quot;)  \n  \n&#x2F;&#x2F; 声明一个路由结构体  \ntype router struct &#123;  \n   handlers map[string]HandlerFunc  \n&#125;  \n  \nfunc newRouter() *router &#123;  \n   return &amp;router&#123;handlers: make(map[string]HandlerFunc)&#125;  \n&#125;  \n  \n&#x2F;&#x2F; 添加路由  \nfunc (r *router) addRoute(method string, pattern string, handler HandlerFunc) &#123;  \n   log.Printf(&quot;Route %4s - %4s&quot;, method, pattern)  \n   key :&#x3D; method + &quot;-&quot; + pattern  \n   r.handlers[key] &#x3D; handler  \n&#125;  \n  \n&#x2F;&#x2F; 处理路由  \nfunc (r *router) handle(c *Context) &#123;  \n   key :&#x3D; c.Method + &quot;-&quot; + c.Path  \n   if handler, ok :&#x3D; r.handlers[key]; ok &#123;  \n      handler(c)  \n   &#125; else &#123;  \n      c.String(http.StatusNotFound, &quot;404 NOT FOUND: %s\\n&quot;, c.Path)  \n   &#125;  \n&#125;\n\n可以理解为这里面的更偏向底层函数，在gee.go中会有函数反复调用上面的函数。\n框架入口gee.go具体实现\npackage gee  \n  \nimport (  \n   &quot;net&#x2F;http&quot;  \n)  \n  \n&#x2F;&#x2F; 声明函数类型，稍后作为路由map的val  \ntype HandlerFunc func(*Context)  \n  \n&#x2F;&#x2F; 声明一个结构体，为实例的结构，内部包含一个路由表，用map实现  \ntype Engine struct &#123;  \n   router *router  \n&#125;  \n  \n&#x2F;&#x2F; 初始化一个对象，即初始化一个结构体  \nfunc New() *Engine &#123;  \n   return &amp;Engine&#123;router: newRouter()&#125;  \n&#125;  \n  \n&#x2F;&#x2F; 添加一个路由  \nfunc (engine *Engine) addRoute(method string, pattren string, handler HandlerFunc) &#123;  \n   engine.router.addRoute(method, pattren, handler)  \n&#125;  \n  \n&#x2F;&#x2F; 添加GET  \nfunc (engine *Engine) GET(pattern string, handler HandlerFunc) &#123;  \n   engine.addRoute(&quot;GET&quot;, pattern, handler)  \n&#125;  \n  \n&#x2F;&#x2F; 添加POST  \nfunc (engine *Engine) POST(pattern string, handler HandlerFunc) &#123;  \n   engine.addRoute(&quot;POST&quot;, pattern, handler)  \n&#125;  \n  \n&#x2F;&#x2F; 开启web服务，其实就是调用标准库的http.ListenAndServe函数，使用下面的  \nfunc (engine *Engine) Run(addr string) (err error) &#123;  \n   &#x2F;&#x2F; 用实例开启web服务  \n   return http.ListenAndServe(addr, engine)  \n&#125;  \n  \n&#x2F;&#x2F; 用这两个参数，构建一个Context，然后在路由表中去寻找  \nfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;  \n   c :&#x3D; newContext(w, req)  \n   engine.router.handle(c)  \n&#125;\n\n\n\n\n\n\n\n\n\n将router相关代码独立之后，gee.go简单了不少。ServerHTTP接口接管了所有的HTTP请求，相比第一天的代码，这个方法也有细微的调整，在调用router.handle之前，构造了一个Context对象。这个对象目前还非常简单，仅仅是包装了原来的两个参数。\n","slug":"上下文Context","date":"2022-12-02T08:54:00.000Z","categories_index":"","tags_index":"Gee","author_index":"kuan525"},{"id":"0f078f596417876613c3439a68f4ffb7","title":"HTTP基础","content":"使用net/http使用http.HandleFunc(&quot;路径&quot;, 路由处理函数)来将路由注册到路由表，并且绑定对应的处理函数，可以用map实现。使用http.ListenAndServe(&quot;:端口&quot;, nil)，nil其实是一个实例，由于我们没有自己实现，所以他这里调用的是标准库的实例。\n在net/http源码中，Handler是一个接口，需要实现方法ServeHTTP，只要传入了任何实现了ServeHTTP接口的实例，所有的HTTP请求，都交给实例处理了。net/http源码：\npackage http  \n  \ntype Handler interface &#123;  \n    ServeHTTP(w ResponseWriter, r *Request)  \n&#125;  \n  \nfunc ListenAndServe(address string, h Handler) error\n\n自定义ServeHTTP:package main  \n  \nimport (  \n\t&quot;fmt&quot;  \n\t&quot;log&quot;  \n\t&quot;net&#x2F;http&quot;  \n)  \n  \n&#x2F;&#x2F; Engine is the uni handler for all requests  \ntype Engine struct&#123;&#125;  \n  \nfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;  \n\tswitch req.URL.Path &#123;  \n\tcase &quot;&#x2F;&quot;:  \n\t\tfmt.Fprintf(w, &quot;URL.Path &#x3D; %q\\n&quot;, req.URL.Path)  \n\tcase &quot;&#x2F;hello&quot;:  \n\t\tfor k, v :&#x3D; range req.Header &#123;  \n\t\t\tfmt.Fprintf(w, &quot;Header[%q] &#x3D; %q\\n&quot;, k, v)  \n\t\t&#125;  \n\tdefault:  \n\t\tfmt.Fprintf(w, &quot;404 NOT FOUND: %s\\n&quot;, req.URL)  \n\t&#125;  \n&#125;  \n  \nfunc main() &#123;  \n\tengine :&#x3D; new(Engine)  \n\tlog.Fatal(http.ListenAndServe(&quot;:9999&quot;, engine))  \n&#125;\n\n定义一个空结构体Engine，实现方法ServeHTTP，第二个参数Request包含了改HTTP请求的所有信息，第一个参数可以构造响应（返回）。\nmain函数中，我们传入的是自己的实例engine，该实例调用ServeHTTP来匹配路由，在之前我们只需要针对某一路由写处理逻辑handler，在实现了Engine之后，我们拦截了所有的HTTP请求，拥有了统一控制入口，在这里我们可以自由定义路由映射规则，也可以统一添加一些处理逻辑，例如日志、异常处理等。Gee雏形代码目录结构gee&#x2F;  \n  |--gee.go  \n  |--go.mod  \nmain.go  \ngo.mod\ngo.modmodule Gee  \n  \ngo 1.19  \n  \nrequire gee v0.0.0  \n  \nreplace gee &#x3D;&gt; .&#x2F;gee\n\n\n使用replace将gee指向./gee\n\n\n\n\n\n\n\n\n这里需要配置一下版本依赖等等，在外面和里面都初始化一下go mod，上面将gee映射到./gee这里是相对路径，需要保证项目结构如上所示main.gogin.Default()和gin.New()的区别是，gin.Default是对gin.new()的封装，添加了gin内置的gin.Logger()和gin.Recovery()的中间件。\npackage main  \n  \nimport (  \n\t&quot;fmt&quot;  \n\t&quot;net&#x2F;http&quot;  \n  \n\t&quot;gee&quot;  \n)  \n  \nfunc main() &#123;  \n\tr :&#x3D; gee.New()  \n\tr.GET(&quot;&#x2F;&quot;, func(w http.ResponseWriter, req *http.Request) &#123;  \n\t\tfmt.Fprintf(w, &quot;URL.Path &#x3D; %q\\n&quot;, req.URL.Path)  \n\t&#125;)  \n  \n\tr.GET(&quot;&#x2F;hello&quot;, func(w http.ResponseWriter, req *http.Request) &#123;  \n\t\tfor k, v :&#x3D; range req.Header &#123;  \n\t\t\tfmt.Fprintf(w, &quot;Header[%q] &#x3D; %q\\n&quot;, k, v)  \n\t\t&#125;  \n\t&#125;)  \n  \n\tr.Run(&quot;:9999&quot;)  \n&#125;\n使用New()来初始化gee的实例，使用GET()方法添加路由，最后使用Run()来启动服务，这里和gin框架类似，其实都差不多。关于gee的所有函数，都是自己实现。gee.go实现package gee  \n  \nimport (  \n   &quot;fmt&quot;  \n   &quot;net&#x2F;http&quot;)  \n  \n&#x2F;&#x2F; 声明函数类型，稍后作为路由map的val  \ntype HandlerFunc func(http.ResponseWriter, *http.Request)  \n  \n&#x2F;&#x2F; 声明一个结构体，为实例的结构，内部包含一个路由表，用map实现  \ntype Engine struct &#123;  \n   router map[string]HandlerFunc  \n&#125;  \n  \n&#x2F;&#x2F; 初始化一个对象，即初始化一个结构体  \nfunc New() *Engine &#123;  \n   return &amp;Engine&#123;router: make(map[string]HandlerFunc)&#125;  \n&#125;  \n  \n&#x2F;&#x2F; 添加一个路由  \nfunc (engine *Engine) addRoute(method string, pattren string, handler HandlerFunc) &#123;  \n   &#x2F;&#x2F; 拼接，方法+&quot;-&quot;+路由  \n   key :&#x3D; method + &quot;-&quot; + pattren  \n   &#x2F;&#x2F; 当前key添加他自己的处理函数  \n   engine.router[key] &#x3D; handler  \n&#125;  \n  \n&#x2F;&#x2F; 添加GET  \nfunc (engine *Engine) GET(pattern string, handler HandlerFunc) &#123;  \n   engine.addRoute(&quot;GET&quot;, pattern, handler)  \n&#125;  \n  \n&#x2F;&#x2F; 添加POST  \nfunc (engine *Engine) POST(pattern string, handler HandlerFunc) &#123;  \n   engine.addRoute(&quot;POST&quot;, pattern, handler)  \n&#125;  \n  \n&#x2F;&#x2F; 开启web服务，其实就是调用标准库的http.ListenAndServe函数，使用下面的  \nfunc (engine *Engine) Run(addr string) (err error) &#123;  \n   &#x2F;&#x2F; 用实例开启web服务  \n   return http.ListenAndServe(addr, engine)  \n&#125;  \n  \n&#x2F;&#x2F; 在标准库http.ListenAndServe中，第二个参数为nil或者自建的engine  \n&#x2F;&#x2F; http.ListenAndServe函数都会调用该对象的ServeHTTP函数  \n&#x2F;&#x2F; http标准库  \n&#x2F;&#x2F; package http  \n&#x2F;&#x2F;  \n&#x2F;&#x2F; type Handler interface &#123;  \n&#x2F;&#x2F;    ServeHTTP(w ResponseWriter, r *Request)  \n&#x2F;&#x2F; &#125;  \n&#x2F;&#x2F;  \n&#x2F;&#x2F; func ListenAndServe(address string, h Handler) error  \nfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;  \n   key :&#x3D; req.Method + &quot;-&quot; + req.URL.Path  \n   if handler, ok :&#x3D; engine.router[key]; ok &#123;  \n      &#x2F;&#x2F; handler是处理函数  \n      handler(w, req)  \n   &#125; else &#123;  \n      fmt.Fprintf(w, &quot;404 NOT FOUND: %s\\n&quot;, req.URL)  \n   &#125;  \n&#125;\n定义了HandlerFunc，这是提供给框架用户的，用来定义路由映射的处理方法，在Engine中，添加了一种路由映射表，属于静态路由\n当用户调用(*Engine).GET()方法时，回将路由和处理方法注册到映射表router中，(*Engine).Run()方法，是ListenServe到包装。\nEngine实现到ServeHTTP方法的作用就是，解析请求的路径，查找路由映射表，如果找到就执行对应方法（val值），如果找不到就返回404\n\n\n\n\n\n\n\n\n\n\nGee框架的原型如上，实现了路由映射表，提供了用户注册静态路由的方法，包装了启动服务的函数。当前我们还没有标准库net/http其余强大的功能，在后面会实现动态路由、中间件功能\n","slug":"HTTP基础","date":"2022-12-02T05:54:30.000Z","categories_index":"","tags_index":"Gee","author_index":"kuan525"},{"id":"f390a0a8b566878fd44aa08498486b1a","title":"线性dp问题","content":"数字三角形模型【摘花生】:\n\n\n\n\n\n\n\n\n\n状态表示：f[i][j]：从左上角到当前点的最大价值\n状态属性：max\n&gt;f[i][j] &#x3D; max(f[i-1][j], f[i][j-1]) + q[i];\n【最低通行费】\n\n\n\n\n\n\n\n\n\n状态表示：f[i][j]：从左上角到当前点的最小花费\n状态属性：min\n&gt;f[i][j] &#x3D; max(f[i-1][j], f[i][j-1]) + q[i];\n【方格取数】\n\n\n\n\n\n\n\n\n\n状态表示：f[i1][j1][i2][j2]：第一个点在[i1, j2], 第二个点在[i2, j2]的最大价值,并保证两点行走的路径一样长\n状态属性：max\n&gt;int t &#x3D; w[i1][j2];\n&gt;if(i1 !&#x3D;i2 || j1 !&#x3D; j2) t +&#x3D; w[i2][j2]&#x2F;&#x2F;当前两点重合，则只取一次\n&gt;for(int c &#x3D; 0; c &lt;&#x3D; 1; c ++)\nfor(int r &#x3D; 0; r &lt;&#x3D; 1; r ++)\n       f[i1][j2][i1][j2] &#x3D; max(f[i1][j1][i2][j2], f[i1-c][j2-r][i1-c][j2-r] + t);   \n\nf[i1][j1][i2][j2]可以优化为f[k][i1][i2]，因为横纵之和一定，可以用k-i1 == j1等\n【传纸条】\n\n\n\n\n\n\n\n\n\n状态表示：f[i1][j1][i2][j2]：第一个点在[i1, j2], 第二个点在[i2, j2]的最大价值,并保证两点行走的路径一样长\n状态属性：max\n&gt;int t &#x3D; w[i1][j2];\n&gt;if(i1 !&#x3D;i2 || j1 !&#x3D; j2) t +&#x3D; w[i2][j2]&#x2F;&#x2F;当前两点重合，则只取一次\n&gt;for(int c &#x3D; 0; c &lt;&#x3D; 1; c ++)\nfor(int r &#x3D; 0; r &lt;&#x3D; 1; r ++)\n       f[i1][j2][i1][j2] &#x3D; max(f[i1][j1][i2][j2], f[i1-c][j2-r][i1-c][j2-r] + t);  \n\nf[i1][j1][i2][j2]可以优化为f[k][i1][i2]，因为横纵之和一定，可以用k-i1 == j1等\n证明：为什么可以使用【方格取数】一样的状态转移？\n\n假设两条路径相交：则可以左下侧和有上侧的两条不相交的路径（可能有中途相遇点）\n假设有中途相遇点：一定可以通过某条路径的相交点往左下或右上挪动一个位置\n为什么挪动一个位置不影响最后值：我们状态属性是max，所有挪动一个位置得到的价值最会变大，不会变小\n是否需要特判中途相遇点：不用，因为即使前面更新了中途相遇点，后面永远也不会使用这个点（可以绕得到大于或等于的值）\n\n最长上升子序列模型朴素：暴力\n优化：二分，将当前值放入在数组中的合适的位置\n【怪盗基德的滑翔翼】\n\n\n\n\n\n\n\n\n\n求先上升再下降的最大长度\n转换为某个点作为顶点时的山体最大宽度，两遍lis即可，需要两个数组记录，然后相加取max\n【登山】\n\n\n\n\n\n\n\n\n\n求先上升再下降的最大长度\n转换为某个点作为顶点时的山体最大宽度，两遍lcs即可，需要两个数组记录，然后相加取max\n要求严格上升和严格下降\n【合唱队形】\n\n\n\n\n\n\n\n\n\n求先上升再下降的最大长度\n转换为某个点作为顶点时的山体最大宽度，两遍lcs即可，需要两个数组记录，然后相加取max\n要求严格上升和严格下降\n【友好城市】\n\n\n\n\n\n\n\n\n\n转换为互相匹配的两边同增的最大长度\n固定一边，求另一边lis即可\n证明：为什么按照任意一遍排序都可？\n假设左排序比右排序得到的结果大，那么必然存在更多的互相匹配同增最大长度，那么按照右排序也一定能找到这个组合\n【最大上升子序列和】\n\n\n\n\n\n\n\n\n\n求上升子序列的和，这里不一定时最长的。\n状态表示：f[i]：以i点结尾的前i个数组成的序列最大和\n状态属性：max\n状态转移：枚举前面所有小于（原数组权值）i点，取最大的一个转移过来即可（n^2）\n优化：\n我们在找前i个点小于当前点权值同时累计和最大的点的时候，可以通过维护一个树状数组来优化，思路如下：\n\n值域较小，100000，利用下标作为单点权值， tree数组没问题（存放max）\n当前树状数组不再是维护前缀和，而是维护前缀最大数\n假设当前权值为w[i]，只需要找前w[i]-1个数中的最大数即可\n每次需要更新最大值，直接add即可，在add函数里是取max，所以即使传递了一个小的数，也不影响\n\n【拦截导弹】\n\n\n\n\n\n\n\n\n\n最小个下降子序列个数，并集等价于原数组\n维护每一个下降子序列的最小值，顺序遍历原数组，若有大于q[i]，则用q[i]更新大于q[i]的最小数，若没有大于q[i]，则新开一个下降子序列\n证明：为什么这样是可行的？\n\n每个数都要在某个下降子序列中，与其新开一个，不如加在别人后面（末端最小值是一样的，对后面的影响相同，这样可以少开一个）\n如果能加在别人后面，要加在大于q[i]的最小值后面，更大的末端值能容得下更大的后来的值，这是贪心做法\n\n【导弹防御系统】\n\n\n\n\n\n\n\n\n\n若干个上升子序列和下降子序列，并集等价于原数组\ny总说没有更好的办法了，直接爆搜（数据范围：50）\n直接爆搜会t，需要加入一些剪枝，设上升子序列个数为sc，下降子序列个数为sd，记最优解ans = n(每个数一个序列)，当sc+sd&gt;ans则不合理，同时搜到合理方案时及时更新ans，理论上收敛在（1 &lt;&lt; 25）以内\n【最长公共上升子序列】\n\n\n\n\n\n\n\n\n\n状态表示：f[i][j]：所有a[1~i]和b[1~j]中以b[j]结尾的max\n状态属性：max\n状态转移：\n&gt;f[i][j] &#x3D; f[i-1][j];&#x2F;&#x2F;不取最后一组数据\n&gt;if(a[i] &#x3D;&#x3D; b[j])&#123;&#x2F;&#x2F;最后一组数据相等，可以通过f[i-1][1~j-1]中q[j] &lt; a[i]的点转移而来\n   &#x2F;&#x2F;这里是一个循环枚举\n   for(int k &#x3D; 1; k &lt; j; k ++)\n       if(b[j](等价于a[i]) &gt; b[k]) f[i][j] &#x3D; max(f[i][j], f[i-1][k]+1);\n&gt;&#125;\n&gt;&#x2F;************&#x2F;上述做法为三方小常，所有可以卡过，下面给出优化\n&gt;for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)&#123;\n   int maxv &#x3D; 1;&#x2F;&#x2F;维护的是i恒定，j动态情况下的 [i-1][1~j-1]中q[j] &lt; a[i]的点 的最大值\n   for(int j &#x3D; 1; j &lt;&#x3D; n; j ++)&#123;\n       f[i][j] &#x3D; f[i-1][j];\n       if(a[i] &#x3D;&#x3D; b[j]) f[i][j] &#x3D; max(f[i][j], maxv);\n       if(a[i] &gt; b[j]) maxv &#x3D; max(maxv, f[i-1][j] + 1);&#x2F;&#x2F;这一步等价于上个做法中循环k哪一行的用法\n   &#125;\n&gt;&#125;\n\n证明：在后面使用的时候，为什么可以使用maxv？\n因为我们需要用maxv去更新别人的时候，一定有a[i] == b[j]，\n所以前面那么多maxv取max的操作的控制条件a[i] &gt; b[k]中其实就等价与b[j] &gt; b[k]，从而保证是单调递增的，\n我们要找的就是前面小于b[j]的所有b[k]中的最大值，\n但是更新条件是a[i] == b[j],所以直接使用a[i]当作b[j]把后面真实的b[j]要用到的数据先处理出来，\n这其实就是对原来代码的等价变形。\n","slug":"线性dp问题","date":"2022-12-01T14:17:22.000Z","categories_index":"","tags_index":"Algorithm","author_index":"kuan525"},{"id":"32c803d1fefb525b38a8f636ccbac12b","title":"背包问题","content":"【采药】\n\n\n\n\n\n\n\n\n\n01背包\n体积：时间\n价值：草药价值     \n【装箱问题】\n\n\n\n\n\n\n\n\n\n01背包\n体积：体积\n价值：体积\n比较特殊，需要求剩余的最小体积，等价与求我使用所有体积，能达到的最大价值，刚好这个体积就是价值\n【宠物小精灵之收服】\n\n\n\n\n\n\n\n\n\n二维费用背包\n体积：球数量\n重量：体力\n价值：怪物个数\n最后暴力遍历一下使用所有精灵球，得到的最大收服数量，并且剩余体力最多\n这里有一点：我们在打斗的过程中，体力值不能为0，所以假设我们要击败30的体力\n我们就会将这个状态更新在体力为31的状态，并且一定在31这个状态里面\n所以最后遍历一遍找到即可\n怎么理解这个“一定”？\n解释：因为30这个状态被更新的时候，当体力值上限大于30的时候，题目有解，故一定会更新在31状态里面，当体力值上限小于等于30，则无解，则不会更新，最后找解也不会找到30这个状态\n【数字组合】\n\n\n\n\n\n\n\n\n\n01背包\nf[i]表示组成i这个数字的方案数，故可以使用类似01背包问题的方式来写\n两重循环，第二层倒着遍历\n【买书】\n\n\n\n\n\n\n\n\n\n完全背包\nf[i]表示花费n元（全部花完）的所有方案数\n这里需要初始化f[0] = 0\n第一维枚举四本书\n第二维完全背包即可（值域有上限）\n拓展：\n如果题面要求花费n元的所有方案数（不要求全部花完），严格怎么计算？\n思路历程：首先想到的是容斥，状态表示不变，但是在完全背包的时候考虑累加而不是取max，不可行，因为会有重复的方案。\n最后发现，在状态表示不变的情况下，累加最后的f[1~n]即可\n【货币系统1】\n\n\n\n\n\n\n\n\n\n完全背包\nf[i]表示组成面值m的方案数（一定要达到m）\n这里需要初始化f[0] = 0\n第一维枚举所有货币\n第二位完全背包即可（值域有上限）\n【货币系统2】\n\n\n\n\n\n\n\n\n\n完全背包+排序+贪心+剪枝\n首先使用最小的货币单位来完全背包值域，如果这个过程中出现了等额于其他货币的金额，则这个大金额失效，可以去掉。重复这个过程，累计失效的个数，最后用n减去并输出即可\n【多重背包问题 III】\n\n\n\n\n\n\n\n\n\n版本1暴力，版本2二进制优化，版本3单调队列优化，以下给出具体思路和证明\n第一位枚举物品数量\n然后我们得到该物品的体积v、价值w、数量s\n我们将f数组拆开,得到下面：\n&gt;我们把 dp[0] --&gt; dp[m] 写成下面这种形式\n&gt;dp[0], dp[v],   dp[2*v],   dp[3*v],   ... , dp[k*v]\n&gt;dp[1], dp[v+1], dp[2*v+1], dp[3*v+1], ... , dp[k*v+1]\n&gt;dp[2], dp[v+2], dp[2*v+2], dp[3*v+2], ... , dp[k*v+2]\n&gt;...\n&gt;dp[j], dp[v+j], dp[2*v+j], dp[3*v+j], ... , dp[k*v+j]\n\n我们容易知道，只有每一行中的数会相互影响，所以我们单独拿一行出来讨论\n&gt;我们可以得到\n&gt;dp[j]    &#x3D;     dp[j]\n&gt;dp[j+v]  &#x3D; max(dp[j] +  w,  dp[j+v])\n&gt;dp[j+2v] &#x3D; max(dp[j] + 2w,  dp[j+v] +  w, dp[j+2v])\n&gt;dp[j+3v] &#x3D; max(dp[j] + 3w,  dp[j+v] + 2w, dp[j+2v] + w, dp[j+3v])\n\n然后发现没有办法两项合并，所以将数据进行一些转化\n&gt;dp[j]    &#x3D;     dp[j]\n&gt;dp[j+v]  &#x3D; max(dp[j], dp[j+v] - w) + w\n&gt;dp[j+2v] &#x3D; max(dp[j], dp[j+v] - w, dp[j+2v] - 2w) + 2w\n&gt;dp[j+3v] &#x3D; max(dp[j], dp[j+v] - w, dp[j+2v] - 2w, dp[j+3v] - 3w) + 3w\n\n可以发现，虽然dp原数组不是对其的，但是减去一个偏移量就对其了\n每个数的偏移量可以通过下标算出来\n我们思考维护一个单调队列（下降序列），有效项数不能超过s(当前物品的数量)\n同时我们只是需要前s项的最大值（已经减去偏移量）来更新自己\n所以我们单调队列中存储的是具体的背包体积k\n当队尾的q[tt换算成减去偏移量后小于当前枚举到的体积k对应的f值减去偏移量时\n我们就弹出队尾，知道大于或者队列为空为止\n当队列为空，表示不需要前面的值来更新自己，自己本来就比他们大\n当队列不为空，取队头，来更新f[k]。\n由于如果一直直接在f数组上更新的话，可能导致最后的结果是由于两次方当前物品得来\n举例证明：\n&gt;核心在于这一句话，当不更新到一个备份数组中去，而是直接在一个数组上搞，假设当前f[k]被全面某个位置更新，此时物品可用次数变少，但是当该f[k]下面作为g[q[hh]]出现时，会重复使用当前物品，导致可能使用不止s个物品，所以我们只能使用一个滚动数组，这里是使用两个数组，一直交换来操作的\n&gt;f[k] &#x3D; max(f[k], g[q[hh]] + (k-q[hh])&#x2F;v*w);\n\n我觉得该题难点在于需要理解为什么单调队列中要存放体积，为什么用体积搞一搞就能保证“有序”，以及怎么通过体积得到偏移量。\n这里简略解释一下（弱弱）\n尽管单调队列里面存放的是体积（v），但是其实是按照v的“性质”排序，这个性质就是f[v]-偏移量，就能找到前面有效短里面的max，也就是上面的代码段三种的哪个图，然后对应下面的状态转移，加上代码段三种每一句的后缀（ +　ｘ＊ｗ）来转移\n&gt;if(hh &lt;&#x3D; tt) f[k] &#x3D; max(f[k], g[q[hh]] + (k-q[hh])&#x2F;v*w);\n\n解释：\n当单调队列种有元素时，队头就是max（已带偏移量），\ng[q[hh]]：花q[hh]体积得到的最大价值\n(k-q[hh])/v*w：两个状态之前相隔的v的组数，乘以w\n为什么这两个能更新f[k]:\n因为单调队列中的体积是按照他们的性质排序的，我们使用他的队头，使用为他队头对应的哪个状态最大，所以我们使用这个“数字”，我们回到代码块三，假设我们现在在讨论最后一行，我们的队头中是里面的某一个状态，容易看出来，里面所有状态，最后都要加上括号外面的偏移量，所以这里我们只需要找到里面最大的即可，其他的就不用管了。\n下面证明一下为什么最后只使用了最大的哪个数据对应的体积，而没有使用括号后面的偏移量：\n证明:\n我们将代码块三中最后一行取到这里来\n&gt;dp[j+3v] &#x3D; max(dp[j], dp[j+v] - w, dp[j+2v] - 2w, dp[j+3v] - 3w) + 3w\n\n假设我们选择的是第二项dp[j+v] - w,这一项现在在单调队列队头，根据我们的状态转移方程f[k] = max(f[k], g[q[hh]] + (k-q[hh])/v*w);\n我们发现dp[j+v] - w + 3w = dp[j+v] + 2w,使用我们的方法：\n&gt;(k-q[hh])&#x2F;v*w) &#x3D; (j+3v-(j+v) &#x2F; v * w) &#x3D; (2v&#x2F;v*w) &#x3D; 2w\n\n结果惊人的相似，下面给出一个解释这个问题的思路：\n我们成功选到了队头之后，能保证他是那一组里面的max，所以这个数一定会用，于是我们换一个思路，既然这个数一定会被用到，那么表示一定是从这个数转移过来的，那么当前体积和这个体积的差就全部都是当前物品凑起来的，就能够得到个数，进而得到价值，来更新数组即可。\n【庆功会】\n\n\n\n\n\n\n\n\n\n多重背包\n二进制拆包或者单调队列优化都可\n【混合背包问题】\n\n\n\n\n\n\n\n\n\n混合背包，三混\n解法一：多重背包二进制拆包，于01一起做01，完全背包单独完全\n解法二：因为值域上限不大，所有进一步将完全背包也转换为多重背包，最后全变为01背包\n【二维费用的背包问题】\n\n\n\n\n\n\n\n\n\n二维费用的背包\n板子题，三重循环遍历，也可以倒着来滚动数组\n【潜水员】\n\n\n\n\n\n\n\n\n\n二维费用的背包\nf[i][j]：使用i氧气，j氮气，的最小重量\n唯一不同的是这个题是取min的过程，所以需要初始化f数组为0x3f\n并且在二维背包的时候for里面不能和普通的一样（&gt;=V[i]），而是必须到达0\n因为可以出现”气体不一定全给的情况“\n简而言之，就是当前有一个O1  N2  W3的罐子，也可以给f[1][1]更新\n那么for里面没有限制的话，在下面是不是需要特判呢，下面给出一种解法：\n&gt;for(int i &#x3D; 1; i &lt;&#x3D; k; i ++)\n&gt;&#123;\n   int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);&#x2F;&#x2F;氧 氮  重量\n   for(int j &#x3D; w_o; j &gt;&#x3D; 0; j --)\n       for(int z &#x3D; w_n; z &gt;&#x3D; 0; z --)\n       &#123;\n           f[j][z] &#x3D; min(f[j][z], f[max(0, j - a)][max(0, z - b)] + c);\n       &#125;\n&gt;&#125;\n\n和0取max即可，这里所有本来是负数的情况表示有气体没有完全使用的情况，也就是说当前气体就以及溢出了，所以只需要当前这一个罐子，可以从0转移过来，至于可能出现一边小于0一边大于0的情况，这里不会冲突，为什么？因为当我们使用一边小于0一边大于0的情况来更新别人的时候，一边小于0一边大于0的情况在前面一定被处理过，它的f值一定不是0，所以没有问题，这里可以和普通问题一样思考即可，dp具有严格的思维性！\n【机器分配】\n\n\n\n\n\n\n\n\n\n分组背包\n理解为每一个公司可以使用一个电脑，使用两个电脑……，\n三重循环遍历即可。\n题目需要找到一条合法路径，下面给出一种方法：\n我们从倒着遍历，首先找到前面在更新n这个点的时候是从哪个状态转移过来的，如果满足下列情况，就说明满足情况，这时候要即使收敛电脑个数，继续下一次寻找。所以倒着找的意义就体现在这里。\n&gt;for(int i &#x3D; n; i &gt;&#x3D; 1; i --)&#123;\n   for(int j &#x3D; 1; j &lt;&#x3D; m; j ++)&#123;\n       if(f[i][m] &#x3D;&#x3D; f[i-1][m-j] + q[i][j]) &#123; &lt;-----\n           way[i] &#x3D; j;\n           m -&#x3D; j;\n           break;\n       &#125;\n   &#125;\n&gt;&#125;\n\n能不能保证倒着找一定有一组解，会不会出现找到一半没有解的情况？\n当然不会，假设我们找到了当前点的上一个转移点，则上一个转移点一定是再再前面的某个点更新过来，则依此思路能找到最前面的情况，也就是f[0][0]。\n【开心的金明】\n\n\n\n\n\n\n\n\n\n01背包\n体积：价格\n价值：价格*重要程度\n水！\n【有依赖的背包问题】\n\n\n\n\n\n\n\n\n\n树形dp+分组背包\n建树、设计状态表示和状态转移\n为了尽量避开容斥的环节，可以使用以下状态表示\nf[u][j]：以u为根节点使用j体积并且一定使用了u点的max\n这样能保证不用判断子树的容斥\n\n从根节点开始递归，在回溯的时候做其余操作\n任取每一个结点，我们想要更新这个结点，就需要从子树出发\n以每个字数的体积状态来划分，等价于选每个子树中的一种体积（一种状态）\n至此转化为树上的分组背包问题\n为什么要用子树的体积来划分？\n否则则只能使用子树的转移情况来划分，也许是子树对子子树的利用，逐渐退化为爆搜\n体积上限较小，统称为值域较小，是可以作为分组背包来枚举的\n在用子树更新完当前根节点之后，需要将自己加入当前状态中，这里是一定要加入，故倒叙遍历一遍，强行加入\n考虑到一定要加入，所以所有体积小于当前物品体积的状态置为0即可\n\n【背包问题求方案数】\n\n\n\n\n\n\n\n\n\n关于方案数的问题，一般做法为再定义一个数组g,g中下标和f中下标严格对应，再去设计状态表示和转移方程\n定义f[i]：使用了体积为i的背包能装下的最大的价值\n定义g[i]：使用了体积为i并完全使用完的最大方案数\n于是在01背包转移的时候我们有以下转移代码\n&gt;g[0] &#x3D; 1;\n&gt;for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)&#123;&#x2F;&#x2F;物品\n   int v, w; cin &gt;&gt; v &gt;&gt; w;\n   for(int j &#x3D; m; j &gt;&#x3D; v; j --)&#123;&#x2F;&#x2F;01背包\n       int maxv &#x3D; max(f[j], f[j - v] + w);&#x2F;&#x2F;先得到最大值，方便下面判断\n       int cnt &#x3D; 0;\n       if(maxv &#x3D;&#x3D; f[j]) cnt +&#x3D; g[j];    &#x2F;&#x2F;不使用当前物品是max，则加上方案数\n       if(maxv &#x3D;&#x3D; f[j-v]+w) cnt +&#x3D; g[j-v];&#x2F;&#x2F;使用当前物品是max，则加上方案数\n       g[j] &#x3D; cnt % mod;   &#x2F;&#x2F;这里只在g之间转移，而没有取max这样就严格保证了是使用体积j(全用)的最大方案数\n       f[j] &#x3D; maxv;\n   &#125;\n&gt;&#125;\n\n最后先找一下f中的最大价值是多少，再遍历f,当当前是最大价值的时候，我们对g[i]累加\n代码如下：\n&gt;int maxv &#x3D; 0;\n&gt;for(int i &#x3D; 0; i &lt;&#x3D; m; i ++) maxv &#x3D; max(maxv, f[i]);\n\n&gt;int ans &#x3D; 0;\n&gt;for(int i &#x3D; 0; i &lt;&#x3D; m; i ++)\n   if(f[i] &#x3D;&#x3D; maxv)\n       ans &#x3D; (ans + g[i]) % mod;\n\n&gt;cout &lt;&lt; ans &lt;&lt; endl;\n【背包问题求具体方案】\n\n\n\n\n\n\n\n\n\n在前面我们做过一个题目【机器分配】，也是输出一个方案，但是不要求是方案的最小字典序。\n并且求具体方案的题目大多不能使用滚动数组来优化，因为我们要在最后用到每一层的数据\n上一个题目是分组背包，找方案的时候需要遍历当前分组中的所有元素，该题是01背包，则少一层循环。\n上一层我们是倒着找具体方案，所以找到的不是最小字典序，这里我们需要正着来找\n但是考虑到正着找的话，我们并不能使用再前面的数据，换言之当我们使用f[i]的时候，不能使用前面的数据f[i-1]来更新，只能使用后面的数据，所以我们在前面做01背包的时候，我们从最后一个开始做。\n然后找方案的时候能有靠前面的满足匹配的就一定要选，这样能保证找出的方案的字典序\n【能量石】\n\n\n\n\n\n\n\n\n\n基于贪心的DP问题\n假设我们以及剔除了贡献为0的宝石（最最后面吃的）\n现在我们得到了可以做出贡献的宝石序列a1,a2,a3… ak\n那么对于任意两个位置$$i=al,j=al+1(1&lt;=l&lt;k)$$交换后两个宝石的贡献总和不会变得更大，即（假设之前的总时间为tt ）：$$Ei−t∗Li+Ej−(t+Si)∗Lj&gt;=Ej−t∗Lj+Ei−(t+Sj)∗Li$$\n整理后：$$Si∗Lj&lt;=Sj∗Li$$我们可以把跟i有关的放到一边，调整一下:\n$$Si/Li&lt;=Sj/Lj$$这样，我们只要以如上条件作为宝石间排序的条件，进行一次sort。\n因为对于其他形式的放置规律，必然可以通过交换满足$SiLi&gt;SjLj$的相邻的两项来得到更小值。\n那么最优解的坐标（新的坐标）一定满足：\n$$ai&lt;a2&lt;a3…&lt;ak$$此时转化为01背包问题\nf[i]表示当前正好花费t时间得到的最大值\n转移方程：$$f[t]=max(f[t],f[t−Si]+max(0,Ei−(t−Si)∗Li))$$由于我们背包放物品（宝石）的顺序是坐标从1到n的，所以一定能枚举到最优解。\n初始状态：f[0]=0，其余为负无穷\n答案：$max(f[i])(1&lt;=i&lt;=∑ni=1si)$\n公式摘选自：墨染空\n下面给出我的思考：\n\n前面使用贪心预处理数据，得到先后顺序\n下面利用值域较小，可以枚举的性质，使用f[i]表示恰好使用i的时间吃到的总能量\n吃时候的得到的能量可以通过枚举的当前时间计算而来，价格是固定的\n\n这种类似的题目都是枚举权值的方向来思考状态表示，至于前天的贪心嘛，需要题量来积累。\n【金明的预算方案】\n\n\n\n\n\n\n\n\n\n这道题看起来有一股有依赖的背包，但是实则不然，这个依赖关系比较浅，【有依赖的背包问题】依赖关系较深\n由于每个点只有最多两个子节点，而且不会有孙子结点，所以我们可以枚举当前子节点的所有可能，进而演化为一个分组背包问题。\n记忆点：\n\n分组背包建图时需要两个二维数组，对应付出价值和回报价值\n分组背包没有办法使用滚动数组来优化，如果使用了会导致同一组物品多个被利用\n\n","slug":"背包问题","date":"2022-12-01T14:08:22.000Z","categories_index":"","tags_index":"Algorithm","author_index":"kuan525"}]