[{"id":"cc752e8912b50d572e9477f30896c7fb","title":"上下文Context","content":"\n将路由（router）独立出来，方便之后增强\n设计上下文（Context），封装Request和Response，提供对JSON、HTML等返回类型的支持\n\n设计Context\n\n\n\n\n\n\n\n\n\n对于web服务器来说，无非是根据请求http。Request，构造响应http.ResponseWriter。但是这两个对象提供的接口颗粒太细，比如我们要构造一个完整的响应，需要考虑消息头（Header）和消息体（Body），而Header包含了状态码（StatusCode），消息类型（ContentType）等几乎每次请求都需要设置的信息。因此，如果不进行有效的封装，那么框架的用户将需要写出大量重复，繁杂的代码，而且容易出错，针对常用场景，能够高效地构造HTTP响应是一个好的框架必须考虑的点\n针对使用场景，封装*http.Request和http.ResponseWriter的方法，简化相关接口的调用，只是设计Context的原因之一。对于框架来说，还需要支撑额外的功能，例如，将来解析动态路由，或者框架需要中间件。Context随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由Context承载，因此，设计Context结构，扩展性和复杂性留在内部，而对外简化了接口。路由的处理函数，以及将要实现的中间件，参数都同意使用Context实例，Context里面可以找到任何东西。\n\nContext的具体实现\npackage gee  \n  \nimport (  \n   &quot;encoding&#x2F;json&quot;  \n   &quot;fmt&quot;   &quot;net&#x2F;http&quot;)  \n  \n&#x2F;&#x2F; 别名，方便后面调用JSON  \ntype H map[string]interface&#123;&#125;  \n  \n&#x2F;&#x2F; 上下文结构体，暂时存放http.ResponseWriter和*http.Request以及几个常用  \ntype Context struct &#123;  \n   Writer     http.ResponseWriter  \n   Req        *http.Request  \n   Path       string  \n   Method     string  \n   StatusCode int  \n&#125;  \n  \n&#x2F;&#x2F; 新建一个上下文，将几个数据联立起来  \nfunc newContext(w http.ResponseWriter, req *http.Request) *Context &#123;  \n   return &amp;Context&#123;  \n      Writer: w,  \n      Req:    req,  \n      Path:   req.URL.Path,  \n      Method: req.Method,  \n   &#125;  \n&#125;  \n  \n&#x2F;&#x2F; 访问键值，如果有必要，FormValue会调用ParseMultipartFrom和ParseForm，并忽略这些函数所返回的任何错误。  \n&#x2F;&#x2F; 如果键不存在，返回一个空字符串。  \nfunc (c *Context) PostForm(key string) string &#123;  \n   return c.Req.FormValue(key)  \n&#125;  \n  \n&#x2F;&#x2F; URL是一个结构体，Query是他的特有函数，会返回一个map，Get是map的特有函数。总的是获取键值  \nfunc (c *Context) Query(key string) string &#123;  \n   return c.Req.URL.Query().Get(key)  \n&#125;  \n  \n&#x2F;&#x2F; 更新状态码，并写入返回报文  \nfunc (c *Context) Status(code int) &#123;  \n   c.StatusCode &#x3D; code  \n   c.Writer.WriteHeader(code)  \n&#125;  \n  \n&#x2F;&#x2F; Header返回的是一个map，然后调用一系列函数，设置map的值  \nfunc (c *Context) SetHeader(key string, value string) &#123;  \n   c.Writer.Header().Set(key, value)  \n&#125;  \n  \n&#x2F;&#x2F; 将数据写入到返回报文，values是一个多元素传参，将其并且展开，在下面调用Write函数写入  \nfunc (c *Context) String(code int, format string, values ...interface&#123;&#125;) &#123;  \n   c.SetHeader(&quot;Content-Type&quot;, &quot;text&#x2F;plain&quot;)  \n   c.Status(code)  \n   c.Writer.Write([]byte(fmt.Sprintf(format, values...)))  \n&#125;  \n  \n&#x2F;&#x2F; 处理JSON格式  \nfunc (c *Context) JSON(code int, obj interface&#123;&#125;) &#123;  \n   c.SetHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;)  \n   c.Status(code)  \n   encoder :&#x3D; json.NewEncoder(c.Writer)  \n   if err :&#x3D; encoder.Encode(obj); err !&#x3D; nil &#123;  \n      http.Error(c.Writer, err.Error(), 500)  \n   &#125;  \n&#125;  \n  \n&#x2F;&#x2F; 写入数据  \nfunc (c *Context) Data(code int, data []byte) &#123;  \n   c.Status(code)  \n   c.Writer.Write(data)  \n&#125;  \n  \n&#x2F;&#x2F; 处理HTML格式  \nfunc (c *Context) HTML(code int, html string) &#123;  \n   c.SetHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html&quot;)  \n   c.Status(code)  \n   c.Writer.Write([]byte(html))  \n&#125;\n\n代码开头，给map起一个别名H，使其用法和gin类似，方便后面使用，构建JSOn函数时，显得更简洁。\nContext目前值包含了http.ResponseWriter和 *http.Request，另外提供了对Method和Path这两个常用属性的直接访问。\n提供了访问Query和PostForm参数的方法（注释中有写）\n提供了快速构造String/Data/JSON/HTML响应的方法路由（Router）我们将和路由相关的结构提取出来，放到一个新的文件中，方便下一次对router的功能进行增强，例如提供动态路由的支持，router和handle方法作了一个细微的调整，即handler的参数，变成了Context。Router的具体实现package gee  \n  \nimport (  \n   &quot;log&quot;  \n   &quot;net&#x2F;http&quot;)  \n  \n&#x2F;&#x2F; 声明一个路由结构体  \ntype router struct &#123;  \n   handlers map[string]HandlerFunc  \n&#125;  \n  \nfunc newRouter() *router &#123;  \n   return &amp;router&#123;handlers: make(map[string]HandlerFunc)&#125;  \n&#125;  \n  \n&#x2F;&#x2F; 添加路由  \nfunc (r *router) addRoute(method string, pattern string, handler HandlerFunc) &#123;  \n   log.Printf(&quot;Route %4s - %4s&quot;, method, pattern)  \n   key :&#x3D; method + &quot;-&quot; + pattern  \n   r.handlers[key] &#x3D; handler  \n&#125;  \n  \n&#x2F;&#x2F; 处理路由  \nfunc (r *router) handle(c *Context) &#123;  \n   key :&#x3D; c.Method + &quot;-&quot; + c.Path  \n   if handler, ok :&#x3D; r.handlers[key]; ok &#123;  \n      handler(c)  \n   &#125; else &#123;  \n      c.String(http.StatusNotFound, &quot;404 NOT FOUND: %s\\n&quot;, c.Path)  \n   &#125;  \n&#125;\n\n可以理解为这里面的更偏向底层函数，在gee.go中会有函数反复调用上面的函数。\n框架入口gee.go具体实现\npackage gee  \n  \nimport (  \n   &quot;net&#x2F;http&quot;  \n)  \n  \n&#x2F;&#x2F; 声明函数类型，稍后作为路由map的val  \ntype HandlerFunc func(*Context)  \n  \n&#x2F;&#x2F; 声明一个结构体，为实例的结构，内部包含一个路由表，用map实现  \ntype Engine struct &#123;  \n   router *router  \n&#125;  \n  \n&#x2F;&#x2F; 初始化一个对象，即初始化一个结构体  \nfunc New() *Engine &#123;  \n   return &amp;Engine&#123;router: newRouter()&#125;  \n&#125;  \n  \n&#x2F;&#x2F; 添加一个路由  \nfunc (engine *Engine) addRoute(method string, pattren string, handler HandlerFunc) &#123;  \n   engine.router.addRoute(method, pattren, handler)  \n&#125;  \n  \n&#x2F;&#x2F; 添加GET  \nfunc (engine *Engine) GET(pattern string, handler HandlerFunc) &#123;  \n   engine.addRoute(&quot;GET&quot;, pattern, handler)  \n&#125;  \n  \n&#x2F;&#x2F; 添加POST  \nfunc (engine *Engine) POST(pattern string, handler HandlerFunc) &#123;  \n   engine.addRoute(&quot;POST&quot;, pattern, handler)  \n&#125;  \n  \n&#x2F;&#x2F; 开启web服务，其实就是调用标准库的http.ListenAndServe函数，使用下面的  \nfunc (engine *Engine) Run(addr string) (err error) &#123;  \n   &#x2F;&#x2F; 用实例开启web服务  \n   return http.ListenAndServe(addr, engine)  \n&#125;  \n  \n&#x2F;&#x2F; 用这两个参数，构建一个Context，然后在路由表中去寻找  \nfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;  \n   c :&#x3D; newContext(w, req)  \n   engine.router.handle(c)  \n&#125;\n\n\n\n\n\n\n\n\n\n将router相关代码独立之后，gee.go简单了不少。ServerHTTP接口接管了所有的HTTP请求，相比第一天的代码，这个方法也有细微的调整，在调用router.handle之前，构造了一个Context对象。这个对象目前还非常简单，仅仅是包装了原来的两个参数。\n","slug":"上下文Context","date":"2022-12-02T08:54:00.000Z","categories_index":"","tags_index":"Gee","author_index":"kuan525"},{"id":"0f078f596417876613c3439a68f4ffb7","title":"HTTP基础","content":"使用net/http使用http.HandleFunc(&quot;路径&quot;, 路由处理函数)来将路由注册到路由表，并且绑定对应的处理函数，可以用map实现。使用http.ListenAndServe(&quot;:端口&quot;, nil)，nil其实是一个实例，由于我们没有自己实现，所以他这里调用的是标准库的实例。\n在net/http源码中，Handler是一个接口，需要实现方法ServeHTTP，只要传入了任何实现了ServeHTTP接口的实例，所有的HTTP请求，都交给实例处理了。net/http源码：\npackage http  \n  \ntype Handler interface &#123;  \n    ServeHTTP(w ResponseWriter, r *Request)  \n&#125;  \n  \nfunc ListenAndServe(address string, h Handler) error\n\n自定义ServeHTTP:package main  \n  \nimport (  \n\t&quot;fmt&quot;  \n\t&quot;log&quot;  \n\t&quot;net&#x2F;http&quot;  \n)  \n  \n&#x2F;&#x2F; Engine is the uni handler for all requests  \ntype Engine struct&#123;&#125;  \n  \nfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;  \n\tswitch req.URL.Path &#123;  \n\tcase &quot;&#x2F;&quot;:  \n\t\tfmt.Fprintf(w, &quot;URL.Path &#x3D; %q\\n&quot;, req.URL.Path)  \n\tcase &quot;&#x2F;hello&quot;:  \n\t\tfor k, v :&#x3D; range req.Header &#123;  \n\t\t\tfmt.Fprintf(w, &quot;Header[%q] &#x3D; %q\\n&quot;, k, v)  \n\t\t&#125;  \n\tdefault:  \n\t\tfmt.Fprintf(w, &quot;404 NOT FOUND: %s\\n&quot;, req.URL)  \n\t&#125;  \n&#125;  \n  \nfunc main() &#123;  \n\tengine :&#x3D; new(Engine)  \n\tlog.Fatal(http.ListenAndServe(&quot;:9999&quot;, engine))  \n&#125;\n\n定义一个空结构体Engine，实现方法ServeHTTP，第二个参数Request包含了改HTTP请求的所有信息，第一个参数可以构造响应（返回）。\nmain函数中，我们传入的是自己的实例engine，该实例调用ServeHTTP来匹配路由，在之前我们只需要针对某一路由写处理逻辑handler，在实现了Engine之后，我们拦截了所有的HTTP请求，拥有了统一控制入口，在这里我们可以自由定义路由映射规则，也可以统一添加一些处理逻辑，例如日志、异常处理等。Gee雏形代码目录结构gee&#x2F;  \n  |--gee.go  \n  |--go.mod  \nmain.go  \ngo.mod\ngo.modmodule Gee  \n  \ngo 1.19  \n  \nrequire gee v0.0.0  \n  \nreplace gee &#x3D;&gt; .&#x2F;gee\n\n\n使用replace将gee指向./gee\n\n\n\n\n\n\n\n\n这里需要配置一下版本依赖等等，在外面和里面都初始化一下go mod，上面将gee映射到./gee这里是相对路径，需要保证项目结构如上所示main.go\npackage main  \n  \nimport (  \n\t&quot;fmt&quot;  \n\t&quot;net&#x2F;http&quot;  \n  \n\t&quot;gee&quot;  \n)  \n  \nfunc main() &#123;  \n\tr :&#x3D; gee.New()  \n\tr.GET(&quot;&#x2F;&quot;, func(w http.ResponseWriter, req *http.Request) &#123;  \n\t\tfmt.Fprintf(w, &quot;URL.Path &#x3D; %q\\n&quot;, req.URL.Path)  \n\t&#125;)  \n  \n\tr.GET(&quot;&#x2F;hello&quot;, func(w http.ResponseWriter, req *http.Request) &#123;  \n\t\tfor k, v :&#x3D; range req.Header &#123;  \n\t\t\tfmt.Fprintf(w, &quot;Header[%q] &#x3D; %q\\n&quot;, k, v)  \n\t\t&#125;  \n\t&#125;)  \n  \n\tr.Run(&quot;:9999&quot;)  \n&#125;\n使用New()来初始化gee的实例，使用GET()方法添加路由，最后使用Run()来启动服务，这里和gin框架类似，其实都差不多。关于gee的所有函数，都是自己实现。gee.go实现package gee  \n  \nimport (  \n   &quot;fmt&quot;  \n   &quot;net&#x2F;http&quot;)  \n  \n&#x2F;&#x2F; 声明函数类型，稍后作为路由map的val  \ntype HandlerFunc func(http.ResponseWriter, *http.Request)  \n  \n&#x2F;&#x2F; 声明一个结构体，为实例的结构，内部包含一个路由表，用map实现  \ntype Engine struct &#123;  \n   router map[string]HandlerFunc  \n&#125;  \n  \n&#x2F;&#x2F; 初始化一个对象，即初始化一个结构体  \nfunc New() *Engine &#123;  \n   return &amp;Engine&#123;router: make(map[string]HandlerFunc)&#125;  \n&#125;  \n  \n&#x2F;&#x2F; 添加一个路由  \nfunc (engine *Engine) addRoute(method string, pattren string, handler HandlerFunc) &#123;  \n   &#x2F;&#x2F; 拼接，方法+&quot;-&quot;+路由  \n   key :&#x3D; method + &quot;-&quot; + pattren  \n   &#x2F;&#x2F; 当前key添加他自己的处理函数  \n   engine.router[key] &#x3D; handler  \n&#125;  \n  \n&#x2F;&#x2F; 添加GET  \nfunc (engine *Engine) GET(pattern string, handler HandlerFunc) &#123;  \n   engine.addRoute(&quot;GET&quot;, pattern, handler)  \n&#125;  \n  \n&#x2F;&#x2F; 添加POST  \nfunc (engine *Engine) POST(pattern string, handler HandlerFunc) &#123;  \n   engine.addRoute(&quot;POST&quot;, pattern, handler)  \n&#125;  \n  \n&#x2F;&#x2F; 开启web服务，其实就是调用标准库的http.ListenAndServe函数，使用下面的  \nfunc (engine *Engine) Run(addr string) (err error) &#123;  \n   &#x2F;&#x2F; 用实例开启web服务  \n   return http.ListenAndServe(addr, engine)  \n&#125;  \n  \n&#x2F;&#x2F; 在标准库http.ListenAndServe中，第二个参数为nil或者自建的engine  \n&#x2F;&#x2F; http.ListenAndServe函数都会调用该对象的ServeHTTP函数  \n&#x2F;&#x2F; http标准库  \n&#x2F;&#x2F; package http  \n&#x2F;&#x2F;  \n&#x2F;&#x2F; type Handler interface &#123;  \n&#x2F;&#x2F;    ServeHTTP(w ResponseWriter, r *Request)  \n&#x2F;&#x2F; &#125;  \n&#x2F;&#x2F;  \n&#x2F;&#x2F; func ListenAndServe(address string, h Handler) error  \nfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;  \n   key :&#x3D; req.Method + &quot;-&quot; + req.URL.Path  \n   if handler, ok :&#x3D; engine.router[key]; ok &#123;  \n      &#x2F;&#x2F; handler是处理函数  \n      handler(w, req)  \n   &#125; else &#123;  \n      fmt.Fprintf(w, &quot;404 NOT FOUND: %s\\n&quot;, req.URL)  \n   &#125;  \n&#125;\n定义了HandlerFunc，这是提供给框架用户的，用来定义路由映射的处理方法，在Engine中，添加了一种路由映射表，属于静态路由\n当用户调用(*Engine).GET()方法时，回将路由和处理方法注册到映射表router中，(*Engine).Run()方法，是ListenServe到包装。\nEngine实现到ServeHTTP方法的作用就是，解析请求的路径，查找路由映射表，如果找到就执行对应方法（val值），如果找不到就返回404\n\n\n\n\n\n\n\n\n\n\nGee框架的原型如上，实现了路由映射表，提供了用户注册静态路由的方法，包装了启动服务的函数。当前我们还没有标准库net/http其余强大的功能，在后面会实现动态路由、中间件功能\n","slug":"HTTP基础","date":"2022-12-02T05:54:30.000Z","categories_index":"","tags_index":"Gee","author_index":"kuan525"},{"id":"f390a0a8b566878fd44aa08498486b1a","title":"线性dp问题","content":"数字三角形模型【摘花生】:\n\n\n\n\n\n\n\n\n\n状态表示：f[i][j]：从左上角到当前点的最大价值\n状态属性：max\n&gt;f[i][j] &#x3D; max(f[i-1][j], f[i][j-1]) + q[i];\n【最低通行费】\n\n\n\n\n\n\n\n\n\n状态表示：f[i][j]：从左上角到当前点的最小花费\n状态属性：min\n&gt;f[i][j] &#x3D; max(f[i-1][j], f[i][j-1]) + q[i];\n【方格取数】\n\n\n\n\n\n\n\n\n\n状态表示：f[i1][j1][i2][j2]：第一个点在[i1, j2], 第二个点在[i2, j2]的最大价值,并保证两点行走的路径一样长\n状态属性：max\n&gt;int t &#x3D; w[i1][j2];\n&gt;if(i1 !&#x3D;i2 || j1 !&#x3D; j2) t +&#x3D; w[i2][j2]&#x2F;&#x2F;当前两点重合，则只取一次\n&gt;for(int c &#x3D; 0; c &lt;&#x3D; 1; c ++)\nfor(int r &#x3D; 0; r &lt;&#x3D; 1; r ++)\n       f[i1][j2][i1][j2] &#x3D; max(f[i1][j1][i2][j2], f[i1-c][j2-r][i1-c][j2-r] + t);   \n\nf[i1][j1][i2][j2]可以优化为f[k][i1][i2]，因为横纵之和一定，可以用k-i1 == j1等\n【传纸条】\n\n\n\n\n\n\n\n\n\n状态表示：f[i1][j1][i2][j2]：第一个点在[i1, j2], 第二个点在[i2, j2]的最大价值,并保证两点行走的路径一样长\n状态属性：max\n&gt;int t &#x3D; w[i1][j2];\n&gt;if(i1 !&#x3D;i2 || j1 !&#x3D; j2) t +&#x3D; w[i2][j2]&#x2F;&#x2F;当前两点重合，则只取一次\n&gt;for(int c &#x3D; 0; c &lt;&#x3D; 1; c ++)\nfor(int r &#x3D; 0; r &lt;&#x3D; 1; r ++)\n       f[i1][j2][i1][j2] &#x3D; max(f[i1][j1][i2][j2], f[i1-c][j2-r][i1-c][j2-r] + t);  \n\nf[i1][j1][i2][j2]可以优化为f[k][i1][i2]，因为横纵之和一定，可以用k-i1 == j1等\n证明：为什么可以使用【方格取数】一样的状态转移？\n\n假设两条路径相交：则可以左下侧和有上侧的两条不相交的路径（可能有中途相遇点）\n假设有中途相遇点：一定可以通过某条路径的相交点往左下或右上挪动一个位置\n为什么挪动一个位置不影响最后值：我们状态属性是max，所有挪动一个位置得到的价值最会变大，不会变小\n是否需要特判中途相遇点：不用，因为即使前面更新了中途相遇点，后面永远也不会使用这个点（可以绕得到大于或等于的值）\n\n最长上升子序列模型朴素：暴力\n优化：二分，将当前值放入在数组中的合适的位置\n【怪盗基德的滑翔翼】\n\n\n\n\n\n\n\n\n\n求先上升再下降的最大长度\n转换为某个点作为顶点时的山体最大宽度，两遍lis即可，需要两个数组记录，然后相加取max\n【登山】\n\n\n\n\n\n\n\n\n\n求先上升再下降的最大长度\n转换为某个点作为顶点时的山体最大宽度，两遍lcs即可，需要两个数组记录，然后相加取max\n要求严格上升和严格下降\n【合唱队形】\n\n\n\n\n\n\n\n\n\n求先上升再下降的最大长度\n转换为某个点作为顶点时的山体最大宽度，两遍lcs即可，需要两个数组记录，然后相加取max\n要求严格上升和严格下降\n【友好城市】\n\n\n\n\n\n\n\n\n\n转换为互相匹配的两边同增的最大长度\n固定一边，求另一边lis即可\n证明：为什么按照任意一遍排序都可？\n假设左排序比右排序得到的结果大，那么必然存在更多的互相匹配同增最大长度，那么按照右排序也一定能找到这个组合\n【最大上升子序列和】\n\n\n\n\n\n\n\n\n\n求上升子序列的和，这里不一定时最长的。\n状态表示：f[i]：以i点结尾的前i个数组成的序列最大和\n状态属性：max\n状态转移：枚举前面所有小于（原数组权值）i点，取最大的一个转移过来即可（n^2）\n优化：\n我们在找前i个点小于当前点权值同时累计和最大的点的时候，可以通过维护一个树状数组来优化，思路如下：\n\n值域较小，100000，利用下标作为单点权值， tree数组没问题（存放max）\n当前树状数组不再是维护前缀和，而是维护前缀最大数\n假设当前权值为w[i]，只需要找前w[i]-1个数中的最大数即可\n每次需要更新最大值，直接add即可，在add函数里是取max，所以即使传递了一个小的数，也不影响\n\n【拦截导弹】\n\n\n\n\n\n\n\n\n\n最小个下降子序列个数，并集等价于原数组\n维护每一个下降子序列的最小值，顺序遍历原数组，若有大于q[i]，则用q[i]更新大于q[i]的最小数，若没有大于q[i]，则新开一个下降子序列\n证明：为什么这样是可行的？\n\n每个数都要在某个下降子序列中，与其新开一个，不如加在别人后面（末端最小值是一样的，对后面的影响相同，这样可以少开一个）\n如果能加在别人后面，要加在大于q[i]的最小值后面，更大的末端值能容得下更大的后来的值，这是贪心做法\n\n【导弹防御系统】\n\n\n\n\n\n\n\n\n\n若干个上升子序列和下降子序列，并集等价于原数组\ny总说没有更好的办法了，直接爆搜（数据范围：50）\n直接爆搜会t，需要加入一些剪枝，设上升子序列个数为sc，下降子序列个数为sd，记最优解ans = n(每个数一个序列)，当sc+sd&gt;ans则不合理，同时搜到合理方案时及时更新ans，理论上收敛在（1 &lt;&lt; 25）以内\n【最长公共上升子序列】\n\n\n\n\n\n\n\n\n\n状态表示：f[i][j]：所有a[1~i]和b[1~j]中以b[j]结尾的max\n状态属性：max\n状态转移：\n&gt;f[i][j] &#x3D; f[i-1][j];&#x2F;&#x2F;不取最后一组数据\n&gt;if(a[i] &#x3D;&#x3D; b[j])&#123;&#x2F;&#x2F;最后一组数据相等，可以通过f[i-1][1~j-1]中q[j] &lt; a[i]的点转移而来\n   &#x2F;&#x2F;这里是一个循环枚举\n   for(int k &#x3D; 1; k &lt; j; k ++)\n       if(b[j](等价于a[i]) &gt; b[k]) f[i][j] &#x3D; max(f[i][j], f[i-1][k]+1);\n&gt;&#125;\n&gt;&#x2F;************&#x2F;上述做法为三方小常，所有可以卡过，下面给出优化\n&gt;for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)&#123;\n   int maxv &#x3D; 1;&#x2F;&#x2F;维护的是i恒定，j动态情况下的 [i-1][1~j-1]中q[j] &lt; a[i]的点 的最大值\n   for(int j &#x3D; 1; j &lt;&#x3D; n; j ++)&#123;\n       f[i][j] &#x3D; f[i-1][j];\n       if(a[i] &#x3D;&#x3D; b[j]) f[i][j] &#x3D; max(f[i][j], maxv);\n       if(a[i] &gt; b[j]) maxv &#x3D; max(maxv, f[i-1][j] + 1);&#x2F;&#x2F;这一步等价于上个做法中循环k哪一行的用法\n   &#125;\n&gt;&#125;\n\n证明：在后面使用的时候，为什么可以使用maxv？\n因为我们需要用maxv去更新别人的时候，一定有a[i] == b[j]，\n所以前面那么多maxv取max的操作的控制条件a[i] &gt; b[k]中其实就等价与b[j] &gt; b[k]，从而保证是单调递增的，\n我们要找的就是前面小于b[j]的所有b[k]中的最大值，\n但是更新条件是a[i] == b[j],所以直接使用a[i]当作b[j]把后面真实的b[j]要用到的数据先处理出来，\n这其实就是对原来代码的等价变形。\n","slug":"线性dp问题","date":"2022-12-01T14:17:22.000Z","categories_index":"","tags_index":"Algorithm","author_index":"kuan525"},{"id":"32c803d1fefb525b38a8f636ccbac12b","title":"背包问题","content":"【采药】\n\n\n\n\n\n\n\n\n\n01背包\n体积：时间\n价值：草药价值     \n【装箱问题】\n\n\n\n\n\n\n\n\n\n01背包\n体积：体积\n价值：体积\n比较特殊，需要求剩余的最小体积，等价与求我使用所有体积，能达到的最大价值，刚好这个体积就是价值\n【宠物小精灵之收服】\n\n\n\n\n\n\n\n\n\n二维费用背包\n体积：球数量\n重量：体力\n价值：怪物个数\n最后暴力遍历一下使用所有精灵球，得到的最大收服数量，并且剩余体力最多\n这里有一点：我们在打斗的过程中，体力值不能为0，所以假设我们要击败30的体力\n我们就会将这个状态更新在体力为31的状态，并且一定在31这个状态里面\n所以最后遍历一遍找到即可\n怎么理解这个“一定”？\n解释：因为30这个状态被更新的时候，当体力值上限大于30的时候，题目有解，故一定会更新在31状态里面，当体力值上限小于等于30，则无解，则不会更新，最后找解也不会找到30这个状态\n【数字组合】\n\n\n\n\n\n\n\n\n\n01背包\nf[i]表示组成i这个数字的方案数，故可以使用类似01背包问题的方式来写\n两重循环，第二层倒着遍历\n【买书】\n\n\n\n\n\n\n\n\n\n完全背包\nf[i]表示花费n元（全部花完）的所有方案数\n这里需要初始化f[0] = 0\n第一维枚举四本书\n第二维完全背包即可（值域有上限）\n拓展：\n如果题面要求花费n元的所有方案数（不要求全部花完），严格怎么计算？\n思路历程：首先想到的是容斥，状态表示不变，但是在完全背包的时候考虑累加而不是取max，不可行，因为会有重复的方案。\n最后发现，在状态表示不变的情况下，累加最后的f[1~n]即可\n【货币系统1】\n\n\n\n\n\n\n\n\n\n完全背包\nf[i]表示组成面值m的方案数（一定要达到m）\n这里需要初始化f[0] = 0\n第一维枚举所有货币\n第二位完全背包即可（值域有上限）\n【货币系统2】\n\n\n\n\n\n\n\n\n\n完全背包+排序+贪心+剪枝\n首先使用最小的货币单位来完全背包值域，如果这个过程中出现了等额于其他货币的金额，则这个大金额失效，可以去掉。重复这个过程，累计失效的个数，最后用n减去并输出即可\n【多重背包问题 III】\n\n\n\n\n\n\n\n\n\n版本1暴力，版本2二进制优化，版本3单调队列优化，以下给出具体思路和证明\n第一位枚举物品数量\n然后我们得到该物品的体积v、价值w、数量s\n我们将f数组拆开,得到下面：\n&gt;我们把 dp[0] --&gt; dp[m] 写成下面这种形式\n&gt;dp[0], dp[v],   dp[2*v],   dp[3*v],   ... , dp[k*v]\n&gt;dp[1], dp[v+1], dp[2*v+1], dp[3*v+1], ... , dp[k*v+1]\n&gt;dp[2], dp[v+2], dp[2*v+2], dp[3*v+2], ... , dp[k*v+2]\n&gt;...\n&gt;dp[j], dp[v+j], dp[2*v+j], dp[3*v+j], ... , dp[k*v+j]\n\n我们容易知道，只有每一行中的数会相互影响，所以我们单独拿一行出来讨论\n&gt;我们可以得到\n&gt;dp[j]    &#x3D;     dp[j]\n&gt;dp[j+v]  &#x3D; max(dp[j] +  w,  dp[j+v])\n&gt;dp[j+2v] &#x3D; max(dp[j] + 2w,  dp[j+v] +  w, dp[j+2v])\n&gt;dp[j+3v] &#x3D; max(dp[j] + 3w,  dp[j+v] + 2w, dp[j+2v] + w, dp[j+3v])\n\n然后发现没有办法两项合并，所以将数据进行一些转化\n&gt;dp[j]    &#x3D;     dp[j]\n&gt;dp[j+v]  &#x3D; max(dp[j], dp[j+v] - w) + w\n&gt;dp[j+2v] &#x3D; max(dp[j], dp[j+v] - w, dp[j+2v] - 2w) + 2w\n&gt;dp[j+3v] &#x3D; max(dp[j], dp[j+v] - w, dp[j+2v] - 2w, dp[j+3v] - 3w) + 3w\n\n可以发现，虽然dp原数组不是对其的，但是减去一个偏移量就对其了\n每个数的偏移量可以通过下标算出来\n我们思考维护一个单调队列（下降序列），有效项数不能超过s(当前物品的数量)\n同时我们只是需要前s项的最大值（已经减去偏移量）来更新自己\n所以我们单调队列中存储的是具体的背包体积k\n当队尾的q[tt换算成减去偏移量后小于当前枚举到的体积k对应的f值减去偏移量时\n我们就弹出队尾，知道大于或者队列为空为止\n当队列为空，表示不需要前面的值来更新自己，自己本来就比他们大\n当队列不为空，取队头，来更新f[k]。\n由于如果一直直接在f数组上更新的话，可能导致最后的结果是由于两次方当前物品得来\n举例证明：\n&gt;核心在于这一句话，当不更新到一个备份数组中去，而是直接在一个数组上搞，假设当前f[k]被全面某个位置更新，此时物品可用次数变少，但是当该f[k]下面作为g[q[hh]]出现时，会重复使用当前物品，导致可能使用不止s个物品，所以我们只能使用一个滚动数组，这里是使用两个数组，一直交换来操作的\n&gt;f[k] &#x3D; max(f[k], g[q[hh]] + (k-q[hh])&#x2F;v*w);\n\n我觉得该题难点在于需要理解为什么单调队列中要存放体积，为什么用体积搞一搞就能保证“有序”，以及怎么通过体积得到偏移量。\n这里简略解释一下（弱弱）\n尽管单调队列里面存放的是体积（v），但是其实是按照v的“性质”排序，这个性质就是f[v]-偏移量，就能找到前面有效短里面的max，也就是上面的代码段三种的哪个图，然后对应下面的状态转移，加上代码段三种每一句的后缀（ +　ｘ＊ｗ）来转移\n&gt;if(hh &lt;&#x3D; tt) f[k] &#x3D; max(f[k], g[q[hh]] + (k-q[hh])&#x2F;v*w);\n\n解释：\n当单调队列种有元素时，队头就是max（已带偏移量），\ng[q[hh]]：花q[hh]体积得到的最大价值\n(k-q[hh])/v*w：两个状态之前相隔的v的组数，乘以w\n为什么这两个能更新f[k]:\n因为单调队列中的体积是按照他们的性质排序的，我们使用他的队头，使用为他队头对应的哪个状态最大，所以我们使用这个“数字”，我们回到代码块三，假设我们现在在讨论最后一行，我们的队头中是里面的某一个状态，容易看出来，里面所有状态，最后都要加上括号外面的偏移量，所以这里我们只需要找到里面最大的即可，其他的就不用管了。\n下面证明一下为什么最后只使用了最大的哪个数据对应的体积，而没有使用括号后面的偏移量：\n证明:\n我们将代码块三中最后一行取到这里来\n&gt;dp[j+3v] &#x3D; max(dp[j], dp[j+v] - w, dp[j+2v] - 2w, dp[j+3v] - 3w) + 3w\n\n假设我们选择的是第二项dp[j+v] - w,这一项现在在单调队列队头，根据我们的状态转移方程f[k] = max(f[k], g[q[hh]] + (k-q[hh])/v*w);\n我们发现dp[j+v] - w + 3w = dp[j+v] + 2w,使用我们的方法：\n&gt;(k-q[hh])&#x2F;v*w) &#x3D; (j+3v-(j+v) &#x2F; v * w) &#x3D; (2v&#x2F;v*w) &#x3D; 2w\n\n结果惊人的相似，下面给出一个解释这个问题的思路：\n我们成功选到了队头之后，能保证他是那一组里面的max，所以这个数一定会用，于是我们换一个思路，既然这个数一定会被用到，那么表示一定是从这个数转移过来的，那么当前体积和这个体积的差就全部都是当前物品凑起来的，就能够得到个数，进而得到价值，来更新数组即可。\n【庆功会】\n\n\n\n\n\n\n\n\n\n多重背包\n二进制拆包或者单调队列优化都可\n【混合背包问题】\n\n\n\n\n\n\n\n\n\n混合背包，三混\n解法一：多重背包二进制拆包，于01一起做01，完全背包单独完全\n解法二：因为值域上限不大，所有进一步将完全背包也转换为多重背包，最后全变为01背包\n【二维费用的背包问题】\n\n\n\n\n\n\n\n\n\n二维费用的背包\n板子题，三重循环遍历，也可以倒着来滚动数组\n【潜水员】\n\n\n\n\n\n\n\n\n\n二维费用的背包\nf[i][j]：使用i氧气，j氮气，的最小重量\n唯一不同的是这个题是取min的过程，所以需要初始化f数组为0x3f\n并且在二维背包的时候for里面不能和普通的一样（&gt;=V[i]），而是必须到达0\n因为可以出现”气体不一定全给的情况“\n简而言之，就是当前有一个O1  N2  W3的罐子，也可以给f[1][1]更新\n那么for里面没有限制的话，在下面是不是需要特判呢，下面给出一种解法：\n&gt;for(int i &#x3D; 1; i &lt;&#x3D; k; i ++)\n&gt;&#123;\n   int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);&#x2F;&#x2F;氧 氮  重量\n   for(int j &#x3D; w_o; j &gt;&#x3D; 0; j --)\n       for(int z &#x3D; w_n; z &gt;&#x3D; 0; z --)\n       &#123;\n           f[j][z] &#x3D; min(f[j][z], f[max(0, j - a)][max(0, z - b)] + c);\n       &#125;\n&gt;&#125;\n\n和0取max即可，这里所有本来是负数的情况表示有气体没有完全使用的情况，也就是说当前气体就以及溢出了，所以只需要当前这一个罐子，可以从0转移过来，至于可能出现一边小于0一边大于0的情况，这里不会冲突，为什么？因为当我们使用一边小于0一边大于0的情况来更新别人的时候，一边小于0一边大于0的情况在前面一定被处理过，它的f值一定不是0，所以没有问题，这里可以和普通问题一样思考即可，dp具有严格的思维性！\n【机器分配】\n\n\n\n\n\n\n\n\n\n分组背包\n理解为每一个公司可以使用一个电脑，使用两个电脑……，\n三重循环遍历即可。\n题目需要找到一条合法路径，下面给出一种方法：\n我们从倒着遍历，首先找到前面在更新n这个点的时候是从哪个状态转移过来的，如果满足下列情况，就说明满足情况，这时候要即使收敛电脑个数，继续下一次寻找。所以倒着找的意义就体现在这里。\n&gt;for(int i &#x3D; n; i &gt;&#x3D; 1; i --)&#123;\n   for(int j &#x3D; 1; j &lt;&#x3D; m; j ++)&#123;\n       if(f[i][m] &#x3D;&#x3D; f[i-1][m-j] + q[i][j]) &#123; &lt;-----\n           way[i] &#x3D; j;\n           m -&#x3D; j;\n           break;\n       &#125;\n   &#125;\n&gt;&#125;\n\n能不能保证倒着找一定有一组解，会不会出现找到一半没有解的情况？\n当然不会，假设我们找到了当前点的上一个转移点，则上一个转移点一定是再再前面的某个点更新过来，则依此思路能找到最前面的情况，也就是f[0][0]。\n【开心的金明】\n\n\n\n\n\n\n\n\n\n01背包\n体积：价格\n价值：价格*重要程度\n水！\n【有依赖的背包问题】\n\n\n\n\n\n\n\n\n\n树形dp+分组背包\n建树、设计状态表示和状态转移\n为了尽量避开容斥的环节，可以使用以下状态表示\nf[u][j]：以u为根节点使用j体积并且一定使用了u点的max\n这样能保证不用判断子树的容斥\n\n从根节点开始递归，在回溯的时候做其余操作\n任取每一个结点，我们想要更新这个结点，就需要从子树出发\n以每个字数的体积状态来划分，等价于选每个子树中的一种体积（一种状态）\n至此转化为树上的分组背包问题\n为什么要用子树的体积来划分？\n否则则只能使用子树的转移情况来划分，也许是子树对子子树的利用，逐渐退化为爆搜\n体积上限较小，统称为值域较小，是可以作为分组背包来枚举的\n在用子树更新完当前根节点之后，需要将自己加入当前状态中，这里是一定要加入，故倒叙遍历一遍，强行加入\n考虑到一定要加入，所以所有体积小于当前物品体积的状态置为0即可\n\n【背包问题求方案数】\n\n\n\n\n\n\n\n\n\n关于方案数的问题，一般做法为再定义一个数组g,g中下标和f中下标严格对应，再去设计状态表示和转移方程\n定义f[i]：使用了体积为i的背包能装下的最大的价值\n定义g[i]：使用了体积为i并完全使用完的最大方案数\n于是在01背包转移的时候我们有以下转移代码\n&gt;g[0] &#x3D; 1;\n&gt;for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)&#123;&#x2F;&#x2F;物品\n   int v, w; cin &gt;&gt; v &gt;&gt; w;\n   for(int j &#x3D; m; j &gt;&#x3D; v; j --)&#123;&#x2F;&#x2F;01背包\n       int maxv &#x3D; max(f[j], f[j - v] + w);&#x2F;&#x2F;先得到最大值，方便下面判断\n       int cnt &#x3D; 0;\n       if(maxv &#x3D;&#x3D; f[j]) cnt +&#x3D; g[j];    &#x2F;&#x2F;不使用当前物品是max，则加上方案数\n       if(maxv &#x3D;&#x3D; f[j-v]+w) cnt +&#x3D; g[j-v];&#x2F;&#x2F;使用当前物品是max，则加上方案数\n       g[j] &#x3D; cnt % mod;   &#x2F;&#x2F;这里只在g之间转移，而没有取max这样就严格保证了是使用体积j(全用)的最大方案数\n       f[j] &#x3D; maxv;\n   &#125;\n&gt;&#125;\n\n最后先找一下f中的最大价值是多少，再遍历f,当当前是最大价值的时候，我们对g[i]累加\n代码如下：\n&gt;int maxv &#x3D; 0;\n&gt;for(int i &#x3D; 0; i &lt;&#x3D; m; i ++) maxv &#x3D; max(maxv, f[i]);\n\n&gt;int ans &#x3D; 0;\n&gt;for(int i &#x3D; 0; i &lt;&#x3D; m; i ++)\n   if(f[i] &#x3D;&#x3D; maxv)\n       ans &#x3D; (ans + g[i]) % mod;\n\n&gt;cout &lt;&lt; ans &lt;&lt; endl;\n【背包问题求具体方案】\n\n\n\n\n\n\n\n\n\n在前面我们做过一个题目【机器分配】，也是输出一个方案，但是不要求是方案的最小字典序。\n并且求具体方案的题目大多不能使用滚动数组来优化，因为我们要在最后用到每一层的数据\n上一个题目是分组背包，找方案的时候需要遍历当前分组中的所有元素，该题是01背包，则少一层循环。\n上一层我们是倒着找具体方案，所以找到的不是最小字典序，这里我们需要正着来找\n但是考虑到正着找的话，我们并不能使用再前面的数据，换言之当我们使用f[i]的时候，不能使用前面的数据f[i-1]来更新，只能使用后面的数据，所以我们在前面做01背包的时候，我们从最后一个开始做。\n然后找方案的时候能有靠前面的满足匹配的就一定要选，这样能保证找出的方案的字典序\n【能量石】\n\n\n\n\n\n\n\n\n\n基于贪心的DP问题\n假设我们以及剔除了贡献为0的宝石（最最后面吃的）\n现在我们得到了可以做出贡献的宝石序列a1,a2,a3… ak\n那么对于任意两个位置$$i=al,j=al+1(1&lt;=l&lt;k)$$交换后两个宝石的贡献总和不会变得更大，即（假设之前的总时间为tt ）：$$Ei−t∗Li+Ej−(t+Si)∗Lj&gt;=Ej−t∗Lj+Ei−(t+Sj)∗Li$$\n整理后：$$Si∗Lj&lt;=Sj∗Li$$我们可以把跟i有关的放到一边，调整一下:\n$$Si/Li&lt;=Sj/Lj$$这样，我们只要以如上条件作为宝石间排序的条件，进行一次sort。\n因为对于其他形式的放置规律，必然可以通过交换满足$SiLi&gt;SjLj$的相邻的两项来得到更小值。\n那么最优解的坐标（新的坐标）一定满足：\n$$ai&lt;a2&lt;a3…&lt;ak$$此时转化为01背包问题\nf[i]表示当前正好花费t时间得到的最大值\n转移方程：$$f[t]=max(f[t],f[t−Si]+max(0,Ei−(t−Si)∗Li))$$由于我们背包放物品（宝石）的顺序是坐标从1到n的，所以一定能枚举到最优解。\n初始状态：f[0]=0，其余为负无穷\n答案：$max(f[i])(1&lt;=i&lt;=∑ni=1si)$\n公式摘选自：墨染空\n下面给出我的思考：\n\n前面使用贪心预处理数据，得到先后顺序\n下面利用值域较小，可以枚举的性质，使用f[i]表示恰好使用i的时间吃到的总能量\n吃时候的得到的能量可以通过枚举的当前时间计算而来，价格是固定的\n\n这种类似的题目都是枚举权值的方向来思考状态表示，至于前天的贪心嘛，需要题量来积累。\n【金明的预算方案】\n\n\n\n\n\n\n\n\n\n这道题看起来有一股有依赖的背包，但是实则不然，这个依赖关系比较浅，【有依赖的背包问题】依赖关系较深\n由于每个点只有最多两个子节点，而且不会有孙子结点，所以我们可以枚举当前子节点的所有可能，进而演化为一个分组背包问题。\n记忆点：\n\n分组背包建图时需要两个二维数组，对应付出价值和回报价值\n分组背包没有办法使用滚动数组来优化，如果使用了会导致同一组物品多个被利用\n\n","slug":"背包问题","date":"2022-12-01T14:08:22.000Z","categories_index":"","tags_index":"Algorithm","author_index":"kuan525"}]