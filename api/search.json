[{"id":"32c803d1fefb525b38a8f636ccbac12b","title":"背包问题","content":"【采药】\n\n\n\n\n\n\n\n\n\n01背包\n体积：时间\n价值：草药价值     \n【装箱问题】\n\n\n\n\n\n\n\n\n\n01背包\n体积：体积\n价值：体积\n比较特殊，需要求剩余的最小体积，等价与求我使用所有体积，能达到的最大价值，刚好这个体积就是价值\n【宠物小精灵之收服】\n\n\n\n\n\n\n\n\n\n二维费用背包\n体积：球数量\n重量：体力\n价值：怪物个数\n最后暴力遍历一下使用所有精灵球，得到的最大收服数量，并且剩余体力最多\n这里有一点：我们在打斗的过程中，体力值不能为0，所以假设我们要击败30的体力\n我们就会将这个状态更新在体力为31的状态，并且一定在31这个状态里面\n所以最后遍历一遍找到即可\n怎么理解这个“一定”？\n解释：因为30这个状态被更新的时候，当体力值上限大于30的时候，题目有解，故一定会更新在31状态里面，当体力值上限小于等于30，则无解，则不会更新，最后找解也不会找到30这个状态\n【数字组合】\n\n\n\n\n\n\n\n\n\n01背包\nf[i]表示组成i这个数字的方案数，故可以使用类似01背包问题的方式来写\n两重循环，第二层倒着遍历\n【买书】\n\n\n\n\n\n\n\n\n\n完全背包\nf[i]表示花费n元（全部花完）的所有方案数\n这里需要初始化f[0] = 0\n第一维枚举四本书\n第二维完全背包即可（值域有上限）\n拓展：\n如果题面要求花费n元的所有方案数（不要求全部花完），严格怎么计算？\n思路历程：首先想到的是容斥，状态表示不变，但是在完全背包的时候考虑累加而不是取max，不可行，因为会有重复的方案。\n最后发现，在状态表示不变的情况下，累加最后的f[1~n]即可\n【货币系统1】\n\n\n\n\n\n\n\n\n\n完全背包\nf[i]表示组成面值m的方案数（一定要达到m）\n这里需要初始化f[0] = 0\n第一维枚举所有货币\n第二位完全背包即可（值域有上限）\n【货币系统2】\n\n\n\n\n\n\n\n\n\n完全背包+排序+贪心+剪枝\n首先使用最小的货币单位来完全背包值域，如果这个过程中出现了等额于其他货币的金额，则这个大金额失效，可以去掉。重复这个过程，累计失效的个数，最后用n减去并输出即可\n【多重背包问题 III】\n\n\n\n\n\n\n\n\n\n版本1暴力，版本2二进制优化，版本3单调队列优化，以下给出具体思路和证明\n第一位枚举物品数量\n然后我们得到该物品的体积v、价值w、数量s\n我们将f数组拆开,得到下面：\n&gt;我们把 dp[0] --&gt; dp[m] 写成下面这种形式\n&gt;dp[0], dp[v],   dp[2*v],   dp[3*v],   ... , dp[k*v]\n&gt;dp[1], dp[v+1], dp[2*v+1], dp[3*v+1], ... , dp[k*v+1]\n&gt;dp[2], dp[v+2], dp[2*v+2], dp[3*v+2], ... , dp[k*v+2]\n&gt;...\n&gt;dp[j], dp[v+j], dp[2*v+j], dp[3*v+j], ... , dp[k*v+j]\n\n我们容易知道，只有每一行中的数会相互影响，所以我们单独拿一行出来讨论\n&gt;我们可以得到\n&gt;dp[j]    &#x3D;     dp[j]\n&gt;dp[j+v]  &#x3D; max(dp[j] +  w,  dp[j+v])\n&gt;dp[j+2v] &#x3D; max(dp[j] + 2w,  dp[j+v] +  w, dp[j+2v])\n&gt;dp[j+3v] &#x3D; max(dp[j] + 3w,  dp[j+v] + 2w, dp[j+2v] + w, dp[j+3v])\n\n然后发现没有办法两项合并，所以将数据进行一些转化\n&gt;dp[j]    &#x3D;     dp[j]\n&gt;dp[j+v]  &#x3D; max(dp[j], dp[j+v] - w) + w\n&gt;dp[j+2v] &#x3D; max(dp[j], dp[j+v] - w, dp[j+2v] - 2w) + 2w\n&gt;dp[j+3v] &#x3D; max(dp[j], dp[j+v] - w, dp[j+2v] - 2w, dp[j+3v] - 3w) + 3w\n\n可以发现，虽然dp原数组不是对其的，但是减去一个偏移量就对其了\n每个数的偏移量可以通过下标算出来\n我们思考维护一个单调队列（下降序列），有效项数不能超过s(当前物品的数量)\n同时我们只是需要前s项的最大值（已经减去偏移量）来更新自己\n所以我们单调队列中存储的是具体的背包体积k\n当队尾的q[tt换算成减去偏移量后小于当前枚举到的体积k对应的f值减去偏移量时\n我们就弹出队尾，知道大于或者队列为空为止\n当队列为空，表示不需要前面的值来更新自己，自己本来就比他们大\n当队列不为空，取队头，来更新f[k]。\n由于如果一直直接在f数组上更新的话，可能导致最后的结果是由于两次方当前物品得来\n举例证明：\n&gt;核心在于这一句话，当不更新到一个备份数组中去，而是直接在一个数组上搞，假设当前f[k]被全面某个位置更新，此时物品可用次数变少，但是当该f[k]下面作为g[q[hh]]出现时，会重复使用当前物品，导致可能使用不止s个物品，所以我们只能使用一个滚动数组，这里是使用两个数组，一直交换来操作的\n&gt;f[k] &#x3D; max(f[k], g[q[hh]] + (k-q[hh])&#x2F;v*w);\n\n我觉得该题难点在于需要理解为什么单调队列中要存放体积，为什么用体积搞一搞就能保证“有序”，以及怎么通过体积得到偏移量。\n这里简略解释一下（弱弱）\n尽管单调队列里面存放的是体积（v），但是其实是按照v的“性质”排序，这个性质就是f[v]-偏移量，就能找到前面有效短里面的max，也就是上面的代码段三种的哪个图，然后对应下面的状态转移，加上代码段三种每一句的后缀（ +　ｘ＊ｗ）来转移\n&gt;if(hh &lt;&#x3D; tt) f[k] &#x3D; max(f[k], g[q[hh]] + (k-q[hh])&#x2F;v*w);\n\n解释：\n当单调队列种有元素时，队头就是max（已带偏移量），\ng[q[hh]]：花q[hh]体积得到的最大价值\n(k-q[hh])/v*w：两个状态之前相隔的v的组数，乘以w\n为什么这两个能更新f[k]:\n因为单调队列中的体积是按照他们的性质排序的，我们使用他的队头，使用为他队头对应的哪个状态最大，所以我们使用这个“数字”，我们回到代码块三，假设我们现在在讨论最后一行，我们的队头中是里面的某一个状态，容易看出来，里面所有状态，最后都要加上括号外面的偏移量，所以这里我们只需要找到里面最大的即可，其他的就不用管了。\n下面证明一下为什么最后只使用了最大的哪个数据对应的体积，而没有使用括号后面的偏移量：\n证明:\n我们将代码块三中最后一行取到这里来\n&gt;dp[j+3v] &#x3D; max(dp[j], dp[j+v] - w, dp[j+2v] - 2w, dp[j+3v] - 3w) + 3w\n\n假设我们选择的是第二项dp[j+v] - w,这一项现在在单调队列队头，根据我们的状态转移方程f[k] = max(f[k], g[q[hh]] + (k-q[hh])/v*w);\n我们发现dp[j+v] - w + 3w = dp[j+v] + 2w,使用我们的方法：\n&gt;(k-q[hh])&#x2F;v*w) &#x3D; (j+3v-(j+v) &#x2F; v * w) &#x3D; (2v&#x2F;v*w) &#x3D; 2w\n\n结果惊人的相似，下面给出一个解释这个问题的思路：\n我们成功选到了队头之后，能保证他是那一组里面的max，所以这个数一定会用，于是我们换一个思路，既然这个数一定会被用到，那么表示一定是从这个数转移过来的，那么当前体积和这个体积的差就全部都是当前物品凑起来的，就能够得到个数，进而得到价值，来更新数组即可。\n【庆功会】\n\n\n\n\n\n\n\n\n\n多重背包\n二进制拆包或者单调队列优化都可\n【混合背包问题】\n\n\n\n\n\n\n\n\n\n混合背包，三混\n解法一：多重背包二进制拆包，于01一起做01，完全背包单独完全\n解法二：因为值域上限不大，所有进一步将完全背包也转换为多重背包，最后全变为01背包\n【二维费用的背包问题】\n\n\n\n\n\n\n\n\n\n二维费用的背包\n板子题，三重循环遍历，也可以倒着来滚动数组\n【潜水员】\n\n\n\n\n\n\n\n\n\n二维费用的背包\nf[i][j]：使用i氧气，j氮气，的最小重量\n唯一不同的是这个题是取min的过程，所以需要初始化f数组为0x3f\n并且在二维背包的时候for里面不能和普通的一样（&gt;=V[i]），而是必须到达0\n因为可以出现”气体不一定全给的情况“\n简而言之，就是当前有一个O1  N2  W3的罐子，也可以给f[1][1]更新\n那么for里面没有限制的话，在下面是不是需要特判呢，下面给出一种解法：\n&gt;for(int i &#x3D; 1; i &lt;&#x3D; k; i ++)\n&gt;&#123;\n   int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);&#x2F;&#x2F;氧 氮  重量\n   for(int j &#x3D; w_o; j &gt;&#x3D; 0; j --)\n       for(int z &#x3D; w_n; z &gt;&#x3D; 0; z --)\n       &#123;\n           f[j][z] &#x3D; min(f[j][z], f[max(0, j - a)][max(0, z - b)] + c);\n       &#125;\n&gt;&#125;\n\n和0取max即可，这里所有本来是负数的情况表示有气体没有完全使用的情况，也就是说当前气体就以及溢出了，所以只需要当前这一个罐子，可以从0转移过来，至于可能出现一边小于0一边大于0的情况，这里不会冲突，为什么？因为当我们使用一边小于0一边大于0的情况来更新别人的时候，一边小于0一边大于0的情况在前面一定被处理过，它的f值一定不是0，所以没有问题，这里可以和普通问题一样思考即可，dp具有严格的思维性！\n【机器分配】\n\n\n\n\n\n\n\n\n\n分组背包\n理解为每一个公司可以使用一个电脑，使用两个电脑……，\n三重循环遍历即可。\n题目需要找到一条合法路径，下面给出一种方法：\n我们从倒着遍历，首先找到前面在更新n这个点的时候是从哪个状态转移过来的，如果满足下列情况，就说明满足情况，这时候要即使收敛电脑个数，继续下一次寻找。所以倒着找的意义就体现在这里。\n&gt;for(int i &#x3D; n; i &gt;&#x3D; 1; i --)&#123;\n   for(int j &#x3D; 1; j &lt;&#x3D; m; j ++)&#123;\n       if(f[i][m] &#x3D;&#x3D; f[i-1][m-j] + q[i][j]) &#123; &lt;-----\n           way[i] &#x3D; j;\n           m -&#x3D; j;\n           break;\n       &#125;\n   &#125;\n&gt;&#125;\n\n能不能保证倒着找一定有一组解，会不会出现找到一半没有解的情况？\n当然不会，假设我们找到了当前点的上一个转移点，则上一个转移点一定是再再前面的某个点更新过来，则依此思路能找到最前面的情况，也就是f[0][0]。\n【开心的金明】\n\n\n\n\n\n\n\n\n\n01背包\n体积：价格\n价值：价格*重要程度\n水！\n【有依赖的背包问题】\n\n\n\n\n\n\n\n\n\n树形dp+分组背包\n建树、设计状态表示和状态转移\n为了尽量避开容斥的环节，可以使用以下状态表示\nf[u][j]：以u为根节点使用j体积并且一定使用了u点的max\n这样能保证不用判断子树的容斥\n\n从根节点开始递归，在回溯的时候做其余操作\n任取每一个结点，我们想要更新这个结点，就需要从子树出发\n以每个字数的体积状态来划分，等价于选每个子树中的一种体积（一种状态）\n至此转化为树上的分组背包问题\n为什么要用子树的体积来划分？\n否则则只能使用子树的转移情况来划分，也许是子树对子子树的利用，逐渐退化为爆搜\n体积上限较小，统称为值域较小，是可以作为分组背包来枚举的\n在用子树更新完当前根节点之后，需要将自己加入当前状态中，这里是一定要加入，故倒叙遍历一遍，强行加入\n考虑到一定要加入，所以所有体积小于当前物品体积的状态置为0即可\n\n【背包问题求方案数】\n\n\n\n\n\n\n\n\n\n关于方案数的问题，一般做法为再定义一个数组g,g中下标和f中下标严格对应，再去设计状态表示和转移方程\n定义f[i]：使用了体积为i的背包能装下的最大的价值\n定义g[i]：使用了体积为i并完全使用完的最大方案数\n于是在01背包转移的时候我们有以下转移代码\n&gt;g[0] &#x3D; 1;\n&gt;for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)&#123;&#x2F;&#x2F;物品\n   int v, w; cin &gt;&gt; v &gt;&gt; w;\n   for(int j &#x3D; m; j &gt;&#x3D; v; j --)&#123;&#x2F;&#x2F;01背包\n       int maxv &#x3D; max(f[j], f[j - v] + w);&#x2F;&#x2F;先得到最大值，方便下面判断\n       int cnt &#x3D; 0;\n       if(maxv &#x3D;&#x3D; f[j]) cnt +&#x3D; g[j];    &#x2F;&#x2F;不使用当前物品是max，则加上方案数\n       if(maxv &#x3D;&#x3D; f[j-v]+w) cnt +&#x3D; g[j-v];&#x2F;&#x2F;使用当前物品是max，则加上方案数\n       g[j] &#x3D; cnt % mod;   &#x2F;&#x2F;这里只在g之间转移，而没有取max这样就严格保证了是使用体积j(全用)的最大方案数\n       f[j] &#x3D; maxv;\n   &#125;\n&gt;&#125;\n\n最后先找一下f中的最大价值是多少，再遍历f,当当前是最大价值的时候，我们对g[i]累加\n代码如下：\n&gt;int maxv &#x3D; 0;\n&gt;for(int i &#x3D; 0; i &lt;&#x3D; m; i ++) maxv &#x3D; max(maxv, f[i]);\n\n&gt;int ans &#x3D; 0;\n&gt;for(int i &#x3D; 0; i &lt;&#x3D; m; i ++)\n   if(f[i] &#x3D;&#x3D; maxv)\n       ans &#x3D; (ans + g[i]) % mod;\n\n&gt;cout &lt;&lt; ans &lt;&lt; endl;\n【背包问题求具体方案】\n\n\n\n\n\n\n\n\n\n在前面我们做过一个题目【机器分配】，也是输出一个方案，但是不要求是方案的最小字典序。\n并且求具体方案的题目大多不能使用滚动数组来优化，因为我们要在最后用到每一层的数据\n上一个题目是分组背包，找方案的时候需要遍历当前分组中的所有元素，该题是01背包，则少一层循环。\n上一层我们是倒着找具体方案，所以找到的不是最小字典序，这里我们需要正着来找\n但是考虑到正着找的话，我们并不能使用再前面的数据，换言之当我们使用f[i]的时候，不能使用前面的数据f[i-1]来更新，只能使用后面的数据，所以我们在前面做01背包的时候，我们从最后一个开始做。\n然后找方案的时候能有靠前面的满足匹配的就一定要选，这样能保证找出的方案的字典序\n【能量石】\n\n\n\n\n\n\n\n\n\n基于贪心的DP问题\n假设我们以及剔除了贡献为0的宝石（最最后面吃的）\n现在我们得到了可以做出贡献的宝石序列a1,a2,a3… ak\n那么对于任意两个位置$$i=al,j=al+1(1&lt;=l&lt;k)$$交换后两个宝石的贡献总和不会变得更大，即（假设之前的总时间为tt ）：$$Ei−t∗Li+Ej−(t+Si)∗Lj&gt;=Ej−t∗Lj+Ei−(t+Sj)∗Li$$\n整理后：$$Si∗Lj&lt;=Sj∗Li$$我们可以把跟i有关的放到一边，调整一下:\n$$Si/Li&lt;=Sj/Lj$$这样，我们只要以如上条件作为宝石间排序的条件，进行一次sort。\n因为对于其他形式的放置规律，必然可以通过交换满足$SiLi&gt;SjLj$的相邻的两项来得到更小值。\n那么最优解的坐标（新的坐标）一定满足：\n$$ai&lt;a2&lt;a3…&lt;ak$$此时转化为01背包问题\nf[i]表示当前正好花费t时间得到的最大值\n转移方程：$$f[t]=max(f[t],f[t−Si]+max(0,Ei−(t−Si)∗Li))$$由于我们背包放物品（宝石）的顺序是坐标从1到n的，所以一定能枚举到最优解。\n初始状态：f[0]=0，其余为负无穷\n答案：$max(f[i])(1&lt;=i&lt;=∑ni=1si)$\n公式摘选自：墨染空\n下面给出我的思考：\n\n前面使用贪心预处理数据，得到先后顺序\n下面利用值域较小，可以枚举的性质，使用f[i]表示恰好使用i的时间吃到的总能量\n吃时候的得到的能量可以通过枚举的当前时间计算而来，价格是固定的\n\n这种类似的题目都是枚举权值的方向来思考状态表示，至于前天的贪心嘛，需要题量来积累。\n【金明的预算方案】\n\n\n\n\n\n\n\n\n\n这道题看起来有一股有依赖的背包，但是实则不然，这个依赖关系比较浅，【有依赖的背包问题】依赖关系较深\n由于每个点只有最多两个子节点，而且不会有孙子结点，所以我们可以枚举当前子节点的所有可能，进而演化为一个分组背包问题。\n记忆点：\n\n分组背包建图时需要两个二维数组，对应付出价值和回报价值\n分组背包没有办法使用滚动数组来优化，如果使用了会导致同一组物品多个被利用\n\n","slug":"背包问题","date":"2022-12-01T14:08:22.000Z","categories_index":"","tags_index":"Algorithm","author_index":"kuan525"},{"id":"a97de711fca56d7e0180d7ad3be23184","title":"kuan525'test","content":"try\n1232。234\n\n\n","slug":"kuan525-test","date":"2022-12-01T09:11:25.000Z","categories_index":"","tags_index":"","author_index":"kuan525"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-12-01T08:53:05.732Z","categories_index":"","tags_index":"","author_index":"kuan525"}]